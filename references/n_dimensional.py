# -*- coding: utf-8 -*-
"""N_Dimensional.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/github/tum-pbs/PhiML/blob/main/docs/N_Dimensional.ipynb

# Writing *n*-dimensional Code with Œ¶<sub>ML</sub>

[![Colab](https://colab.research.google.com/assets/colab-badge.svg)](https://colab.research.google.com/github/tum-pbs/PhiML/blob/main/docs/N_Dimensional.ipynb)
&nbsp; ‚Ä¢ &nbsp; [üåê **Œ¶<sub>ML</sub>**](https://github.com/tum-pbs/PhiML)
&nbsp; ‚Ä¢ &nbsp; [üìñ **Documentation**](https://tum-pbs.github.io/PhiML/)
&nbsp; ‚Ä¢ &nbsp; [üîó **API**](https://tum-pbs.github.io/PhiML/phiml)
&nbsp; ‚Ä¢ &nbsp; [**‚ñ∂ Videos**]()
&nbsp; ‚Ä¢ &nbsp; [<img src="https://github.com/tum-pbs/PhiML/blob/main/docs/images/colab_logo_small.png?raw=1" height=4>](https://colab.research.google.com/github/tum-pbs/PhiML/blob/main/docs/Examples.ipynb) [**Examples**](https://tum-pbs.github.io/PhiML/Examples.html)

Œ¶<sub>ML</sub>'s [dimension types](Shapes.html) allow you to write abstract code that scales with the number of *spatial* dimensions.
"""

# Commented out IPython magic to ensure Python compatibility.
# %%capture
# !pip install phiml
# 
# from phiml import math
# from phiml.math import spatial, channel, instance

"""## Grids

Grids are a popular data structure that in *n* dimensions.
In Œ¶<sub>ML</sub>, each axis of the grid is represented by a spatial dimension.
"""

grid_1d = math.random_uniform(spatial(x=5))
grid_2d = math.random_uniform(spatial(x=3, y=3))
grid_3d = math.random_uniform(spatial(x=16, y=16, z=16))

"""Note that the dimension names are arbitrary.
We chose `x`, `y`, `z` for readability.

Now, let's write a function that outputs the mean of the direct neighbors of each cell.
In 1D, this would be the stencil (.5, 0, .5) and in 2D (0, .25, 0; .25, 0, .25; 0, .25, 0).
"""

def neighbor_mean(grid):
    left, right = math.shift(grid, (-1, 1), padding=math.extrapolation.PERIODIC)
    return math.mean([left, right], math.non_spatial)

"""This function uses [`math.shift()`](phiml/math#phiml.math.shift) to access the left and right neighbor in each direction.
By default, `shift` shifts in all spatial dimensions and lists the result along a new channel dimension.
Then we can take the mean of the `right` and the `left` values to compute the mean of all neighbors.

We can now evaluate the function in 1D, 2D, 3D, etc. and it will automatically derive the correct stencil.
"""

neighbor_mean(grid_1d)

neighbor_mean(grid_2d)

neighbor_mean(grid_3d)

"""To make sure that the stencil is correct, we can look at the [matrix representation](Matrices.html) of our function."""

math.print(math.matrix_from_function(neighbor_mean, grid_1d)[0])

math.print(math.matrix_from_function(neighbor_mean, grid_2d)[0])

"""The same principle holds for all grid functions in the `phiml.math` library.
For example, if we perform a Fourier transform, the algorithm will be selected based on the number of spatial dimensions.
A 1D FFT will always be performed on our 1D grid, even if we add additional non-spatial dimensions.
"""

math.fft(grid_1d)  # 1D FFT

math.fft(grid_2d)  # 2D FFT

math.fft(grid_3d)  # 3D FFT

"""## Dimensions as Components

Not all applications involving physical space use grids to represent data.
Take point clouds or particles for instance.
In these cases, we would represent the dimensionality not by the number of spatial dimensions but by the number of vector components.
"""

points_1d = math.random_uniform(instance(points=4), channel(vector='x'))
points_2d = math.random_uniform(instance(points=4), channel(vector='x,y'))
points_3d = math.random_uniform(instance(points=4), channel(vector='x,y,z'))

"""In these cases, the generalization to *n* dimensions is usually trivial.
Take the following function that computes the pairwise distances.
"""

def pairwise_distances(x):
    return math.vec_length(math.rename_dims(x, 'points', 'others') - x)

"""Here, we compute the distances between each pair of particles on a matrix with dimensions `points` and `others`.
The intermediate matrix of position distances inherits the vector dimension from `x` and [`math.vec_length()`](phiml/math#phiml.math.vec_length) sums all components.
Consequently, this function computes the correct distances in 1D, 2D and 3D.
"""

pairwise_distances(points_1d)

pairwise_distances(points_2d)

pairwise_distances(points_3d)

"""## Further Reading

Here, we focussed on spatial dimensions, but each [dimension type](Shapes.html) plays a unique role in Œ¶<sub>ML</sub>.

The library [Œ¶<sub>Flow</sub>](https://github.com/tum-pbs/PhiFlow) uses Œ¶<sub>ML</sub> to implement an *n*-dimensional incompressible fluid solver.

[üåê **Œ¶<sub>ML</sub>**](https://github.com/tum-pbs/PhiML)
&nbsp; ‚Ä¢ &nbsp; [üìñ **Documentation**](https://tum-pbs.github.io/PhiML/)
&nbsp; ‚Ä¢ &nbsp; [üîó **API**](https://tum-pbs.github.io/PhiML/phiml)
&nbsp; ‚Ä¢ &nbsp; [**‚ñ∂ Videos**]()
&nbsp; ‚Ä¢ &nbsp; [<img src="https://github.com/tum-pbs/PhiML/blob/main/docs/images/colab_logo_small.png?raw=1" height=4>](https://colab.research.google.com/github/tum-pbs/PhiML/blob/main/docs/Examples.ipynb) [**Examples**](https://tum-pbs.github.io/PhiML/Examples.html)
"""