{
    "name": "phi",
    "type": "package",
    "submodules": [
        {
            "type": "module",
            "name": "field",
            "docstring": "The fields module provides a number of data structures and functions to represent continuous, spatially varying data.\n\nAll fields are subclasses of `Field` which provides abstract functions for sampling field values at physical locations.\n\nThe most important field types are:\n\n* `CenteredGrid` embeds a tensor in the physical space. Uses linear interpolation between grid points.\n* `StaggeredGrid` samples the vector components at face centers instead of at cell centers.\n* `Noise` is a function that produces a procedurally generated noise field\n\nUse `grid()` to create a `Grid` from data or by sampling another `Field` or `phi.geom.Geometry`.\nAlternatively, the `phi.physics.Domain` class provides convenience methods for grid creation.\n\nAll fields can be sampled at physical locations or volumes using `sample()` or `reduce_sample()`.\n\nSee the `phi.field` module documentation at https://tum-pbs.github.io/PhiFlow/Fields.html",
            "functions": [
                {
                    "name": "CenteredGrid",
                    "qualname": "CenteredGrid",
                    "docstring": "Create an n-dimensional grid with values sampled at the cell centers.\nA centered grid is defined through its `CenteredGrid.values` `phi.math.Tensor`, its `CenteredGrid.bounds` `phi.geom.Box` describing the physical size, and its `CenteredGrid.extrapolation` (`phi.math.extrapolation.Extrapolation`).\n\nCentered grids support batch, spatial and channel dimensions.\n\nSee Also:\n    `StaggeredGrid`,\n    `Grid`,\n    `Field`,\n    `Field`,\n    module documentation at https://tum-pbs.github.io/PhiFlow/Fields.html\n\nArgs:\n    values: Values to use for the grid.\n        Has to be one of the following:\n\n        * `phi.geom.Geometry`: sets inside values to 1, outside to 0\n        * `Field`: resamples the Field to the staggered sample points\n        * `Number`: uses the value for all sample points\n        * `tuple` or `list`: interprets the sequence as vector, used for all sample points\n        * `phi.math.Tensor` compatible with grid dims: uses tensor values as grid values\n        * Function `values(x)` where `x` is a `phi.math.Tensor` representing the physical location.\n            The spatial dimensions of the grid will be passed as batch dimensions to the function.\n\n    extrapolation: The grid extrapolation determines the value outside the `values` tensor.\n        Allowed types: `float`, `phi.math.Tensor`, `phi.math.extrapolation.Extrapolation`.\n    bounds: Physical size and location of the grid as `phi.geom.Box`.\n        If the resolution is determined through `resolution` of `values`, a `float` can be passed for `bounds` to create a unit box.\n    resolution: Grid resolution as purely spatial `phi.math.Shape`.\n        If `bounds` is given as a `Box`, the resolution may be specified as an `int` to be equal along all axes.\n    **resolution_: Spatial dimensions as keyword arguments. Typically either `resolution` or `spatial_dims` are specified.\n    convert: Whether to convert `values` to the default backend.",
                    "signature": "(values: Any = 0.0, boundary: Any = 0.0, bounds: phi.geom._box.Box = None, resolution: int = None, extrapolation: Any = None, convert=True, **resolution_: int) -> phi.field._field.Field"
                },
                {
                    "name": "PointCloud",
                    "qualname": "PointCloud",
                    "docstring": "A `PointCloud` comprises:\n\n* `elements`: a `Geometry` representing all points or volumes\n* `values`: a `Tensor` representing the values corresponding to `elements`\n* `extrapolation`: an `Extrapolation` defining the field value outside of `values`\n\nThe points / elements of the `PointCloud` are listed along *instance* or *spatial* dimensions of `elements`.\nThese dimensions are automatically added to `values` if not already present.\n\nWhen sampling or resampling a `PointCloud`, the following keyword arguments can be specified.\n\n* `soft`: default=False.\n  If `True`, interpolates smoothly from 1 to 0 between the inside and outside of elements.\n  If `False`, only the center position of the new representation elements is checked against the point cloud elements.\n* `scatter`: default=False.\n  If `True`, scattering will be used to sample the point cloud onto grids. Then, each element of the point cloud can only affect a single cell. This is only recommended when the points are much smaller than the cells.\n* `outside_handling`: default='discard'. One of `'discard'`, `'clamp'`, `'undefined'`.\n* `balance`: default=0.5. Only used when `soft=True`.\n  See the description in `phi.geom.Geometry.approximate_fraction_inside()`.\n\nSee the `phi.field` module documentation at https://tum-pbs.github.io/PhiFlow/Fields.html\n\nArgs:\n    elements: `Tensor` or `Geometry` object specifying the sample points and sizes\n    values: values corresponding to elements\n    extrapolation: values outside elements\n    bounds: Deprecated. Has no use since 2.5.",
                    "signature": "(elements: Union[phiml.math._tensors.Tensor, phi.geom._geom.Geometry, float], values: Any = 1.0, extrapolation: Union[phiml.math.extrapolation.Extrapolation, float] = 0.0, bounds: phi.geom._box.Box = None, variable_attrs=('values', 'geometry'), value_attrs=('values',)) -> phi.field._field.Field"
                },
                {
                    "name": "StaggeredGrid",
                    "qualname": "StaggeredGrid",
                    "docstring": "N-dimensional grid whose vector components are sampled at the respective face centers.\nA staggered grid is defined through its values tensor, its bounds describing the physical size, and its extrapolation.\n\nStaggered grids support batch and spatial dimensions but only one channel dimension for the staggered vector components.\n\nSee Also:\n    `CenteredGrid`,\n    `Grid`,\n    `Field`,\n    `Field`,\n    module documentation at https://tum-pbs.github.io/PhiFlow/Fields.html\n\nArgs:\n    values: Values to use for the grid.\n        Has to be one of the following:\n\n        * `phi.geom.Geometry`: sets inside values to 1, outside to 0\n        * `Field`: resamples the Field to the staggered sample points\n        * `Number`: uses the value for all sample points\n        * `tuple` or `list`: interprets the sequence as vector, used for all sample points\n        * `phi.math.Tensor` with staggered shape: uses tensor values as grid values.\n          Must contain a `vector` dimension with each slice consisting of one more element along the dimension they describe.\n          Use `phi.math.stack()` to manually create this non-uniform tensor.\n        * Function `values(x)` where `x` is a `phi.math.Tensor` representing the physical location.\n            The spatial dimensions of the grid will be passed as batch dimensions to the function.\n\n    boundary: The grid extrapolation determines the value outside the `values` tensor.\n        Allowed types: `float`, `phi.math.Tensor`, `phi.math.extrapolation.Extrapolation`.\n    bounds: Physical size and location of the grid as `phi.geom.Box`.\n        If the resolution is determined through `resolution` of `values`, a `float` can be passed for `bounds` to create a unit box.\n    resolution: Grid resolution as purely spatial `phi.math.Shape`.\n        If `bounds` is given as a `Box`, the resolution may be specified as an `int` to be equal along all axes.\n    convert: Whether to convert `values` to the default backend.\n    **resolution_: Spatial dimensions as keyword arguments. Typically either `resolution` or `spatial_dims` are specified.",
                    "signature": "(values: Any = 0.0, boundary: float = 0, bounds: phi.geom._box.Box = None, resolution: phiml.math._shape.Shape = None, extrapolation: float = None, convert=True, **resolution_: int) -> phi.field._field.Field"
                },
                {
                    "name": "abs",
                    "qualname": "abs_",
                    "docstring": "Computes *||x||<sub>1</sub>*.\nComplex `x` result in matching precision float values.\n\n*Note*: The gradient of this operation is undefined for *x=0*.\nTensorFlow and PyTorch return 0 while Jax returns 1.\n\nArgs:\n    x: `Tensor` or `phiml.math.magic.PhiTreeNode`\n\nReturns:\n    Absolute value of `x` of same type as `x`.",
                    "signature": "(x: ~TensorOrTree) -> ~TensorOrTree"
                },
                {
                    "name": "as_boundary",
                    "qualname": "as_boundary",
                    "docstring": "Returns an `Extrapolation` representing `obj`.\n\nArgs:\n    obj: One of\n\n        * `float` or `Tensor`: Extrapolate with a constant value\n        * `Extrapolation`: Use as-is.\n        * `Field`: Sample values from `obj`, embedding another field inside `obj`.\n\nReturns:\n    `Extrapolation`",
                    "signature": "(obj: Union[phiml.math.extrapolation.Extrapolation, phiml.math._tensors.Tensor, float, phi.field._field.Field, NoneType], _geometry=None) -> phiml.math.extrapolation.Extrapolation"
                },
                {
                    "name": "assert_close",
                    "qualname": "assert_close",
                    "docstring": "Raises an AssertionError if the `values` of the given fields are not close. See `phi.math.assert_close()`.",
                    "signature": "(*fields: phi.field._field.Field, rel_tolerance: float = 1e-05, abs_tolerance: float = 0, msg: str = '', verbose: bool = True)"
                },
                {
                    "name": "bake_extrapolation",
                    "qualname": "bake_extrapolation",
                    "docstring": "Pads `grid` with its current extrapolation.\nFor `StaggeredGrid`s, the resulting grid will have a consistent shape, independent of the original extrapolation.\n\nArgs:\n    grid: `CenteredGrid` or `StaggeredGrid`.\n\nReturns:\n    Padded grid with extrapolation `phi.math.extrapolation.NONE`.",
                    "signature": "(grid: phi.field._field.Field) -> phi.field._field.Field"
                },
                {
                    "name": "cast",
                    "qualname": "cast",
                    "docstring": "Casts `x` to a different data type.\n\nImplementations:\n\n* NumPy: [`x.astype()`](numpy.ndarray.astype)\n* PyTorch: [`x.to()`](https://pytorch.org/docs/stable/tensors.html#torch.Tensor.to)\n* TensorFlow: [`tf.cast`](https://www.tensorflow.org/api_docs/python/tf/cast)\n* Jax: [`jax.numpy.array`](https://jax.readthedocs.io/en/latest/_autosummary/jax.numpy.array.html)\n\nSee Also:\n    `to_float`, `to_int32`, `to_int64`, `to_complex`.\n\nArgs:\n    x: `Tensor`\n    dtype: New data type as `phiml.math.DType`, e.g. `DType(int, 16)`.\n\nReturns:\n    `Tensor` with data type `dtype`",
                    "signature": "(x: ~MagicType, dtype: Union[phiml.backend._dtype.DType, type]) -> ~OtherMagicType"
                },
                {
                    "name": "ceil",
                    "qualname": "ceil",
                    "docstring": "Computes *\u2308x\u2309* of the `Tensor` or `phiml.math.magic.PhiTreeNode` `x`.",
                    "signature": "(x: ~TensorOrTree) -> ~TensorOrTree"
                },
                {
                    "name": "center_of_mass",
                    "qualname": "center_of_mass",
                    "docstring": "Compute the center of mass of a density field.\n\nArgs:\n    density: Scalar `Field`\n\nReturns:\n    `Tensor` holding only batch dimensions.",
                    "signature": "(density: phi.field._field.Field)"
                },
                {
                    "name": "concat",
                    "qualname": "concat",
                    "docstring": "Concatenates the given `Field`s along `dim`.\n\nSee Also:\n    `stack()`.\n\nArgs:\n    fields: List of matching `Field` instances.\n    dim: Concatenation dimension as `Shape`. Size is ignored.\n\nReturns:\n    `Field` matching concatenated fields.",
                    "signature": "(fields: Sequence[phi.field._field.Field], dim: str) -> phi.field._field.Field"
                },
                {
                    "name": "convert",
                    "qualname": "convert",
                    "docstring": "Convert the native representation of a `Tensor` or `phiml.math.magic.PhiTreeNode` to the native format of `backend`.\n\n*Warning*: This operation breaks the automatic differentiation chain.\n\nSee Also:\n    `phiml.math.backend.convert()`.\n\nArgs:\n    x: `Tensor` to convert. If `x` is a `phiml.math.magic.PhiTreeNode`, its variable attributes are converted.\n    backend: Target backend. If `None`, uses the current default backend, see `phiml.math.backend.backend()`.\n\nReturns:\n    `Tensor` with native representation belonging to `backend`.",
                    "signature": "(x, backend: phiml.backend._backend.Backend = None, use_dlpack=True)"
                },
                {
                    "name": "cos",
                    "qualname": "cos",
                    "docstring": "Computes *cos(x)* of the `Tensor` or `phiml.math.magic.PhiTreeNode` `x`.",
                    "signature": "(x: ~TensorOrTree) -> ~TensorOrTree"
                },
                {
                    "name": "curl",
                    "qualname": "curl",
                    "docstring": "Computes the finite-difference curl of the give 2D `StaggeredGrid`.\n\nArgs:\n    field: `Field`\n    at: Either `center` or `face`.",
                    "signature": "(field: phi.field._field.Field, at='corner')"
                },
                {
                    "name": "divergence",
                    "qualname": "divergence",
                    "docstring": "Computes the divergence of a grid using finite differences.\n\nThis function can operate in two modes depending on the type of `field`:\n\n* `CenteredGrid` approximates the divergence at cell centers using central differences\n* `StaggeredGrid` exactly computes the divergence at cell centers\n\nArgs:\n    field: vector field as `CenteredGrid` or `StaggeredGrid`\n    order: Spatial order of accuracy.\n        Higher orders entail larger stencils and more computation time but result in more accurate results assuming a large enough resolution.\n        Supported: 2 explicit, 4 explicit, 6 implicit.\n    implicit: When a `Solve` object is passed, performs an implicit operation with the specified solver and tolerances.\n        Otherwise, an explicit stencil is used.\n    implicitness: specifies the size of the implicit stencil in case an implicit treatment is used\n    upwind: For unstructured meshes only. Whether to use upwind interpolation.\n\nReturns:\n    Divergence field as `CenteredGrid`",
                    "signature": "(field: phi.field._field.Field, order=2, implicit: phiml.math._optimize.Solve = None, upwind: phi.field._field.Field = None, implicitness: int = None) -> <function CenteredGrid at 0x000001F5FFB63CE0>"
                },
                {
                    "name": "downsample2x",
                    "qualname": "downsample2x",
                    "docstring": "Reduces the number of sample points by a factor of 2 in each spatial dimension.\nThe new values are determined via linear interpolation.\n\nSee Also:\n    `upsample2x()`.\n\nArgs:\n    grid: `CenteredGrid` or `StaggeredGrid`.\n\nReturns:\n    `Grid` of same type as `grid`.",
                    "signature": "(grid: phi.field._field.Field) -> phi.field._field.Field"
                },
                {
                    "name": "exp",
                    "qualname": "exp",
                    "docstring": "Computes *exp(x)* of the `Tensor` or `phiml.math.magic.PhiTreeNode` `x`.",
                    "signature": "(x: ~TensorOrTree) -> ~TensorOrTree"
                },
                {
                    "name": "finite_fill",
                    "qualname": "finite_fill",
                    "docstring": "Extrapolates values of `grid` which are marked by nonzero values in `valid` using `phi.math.masked_fill().\nIf `values` is a StaggeredGrid, its components get extrapolated independently.\n\nArgs:\n    grid: Grid holding the values for extrapolation and possible non-finite values to be filled.\n    distance: Number of extrapolation steps, i.e. how far a cell can be from the closest finite value to get filled.\n    diagonal: Whether to extrapolate values to their diagonal neighbors per step.\n\nReturns:\n    grid: Grid with extrapolated values.\n    valid: binary Grid marking all valid values after extrapolation.",
                    "signature": "(grid: phi.field._field.Field, distance=1, diagonal=True) -> phi.field._field.Field"
                },
                {
                    "name": "floor",
                    "qualname": "floor",
                    "docstring": "Computes *\u230ax\u230b* of the `Tensor` or `phiml.math.magic.PhiTreeNode` `x`.",
                    "signature": "(x: ~TensorOrTree) -> ~TensorOrTree"
                },
                {
                    "name": "fourier_laplace",
                    "qualname": "fourier_laplace",
                    "docstring": "See `phi.math.fourier_laplace()`",
                    "signature": "(grid: phi.field._field.Field, times=1) -> phi.field._field.Field"
                },
                {
                    "name": "fourier_poisson",
                    "qualname": "fourier_poisson",
                    "docstring": "See `phi.math.fourier_poisson()`",
                    "signature": "(grid: phi.field._field.Field, times=1) -> phi.field._field.Field"
                },
                {
                    "name": "frequency_loss",
                    "qualname": "frequency_loss",
                    "docstring": "Penalizes the squared `values` in frequency (Fourier) space.\nLower frequencies are weighted more strongly then higher frequencies, depending on `frequency_falloff`.\n\nArgs:\n    x: `Tensor` or `phiml.math.magic.PhiTreeNode` Values to penalize, typically `actual - target`.\n    frequency_falloff: Large values put more emphasis on lower frequencies, 1.0 weights all frequencies equally.\n        *Note*: The total loss is not normalized. Varying the value will result in losses of different magnitudes.\n    threshold: Frequency amplitudes below this value are ignored.\n        Setting this to zero may cause infinities or NaN values during backpropagation.\n    ignore_mean: If `True`, does not penalize the mean value (frequency=0 component).\n\nReturns:\n  Scalar loss value",
                    "signature": "(x, frequency_falloff: float = 100, threshold=1e-05, ignore_mean=False, n=2) -> phiml.math._tensors.Tensor"
                },
                {
                    "name": "functional_gradient",
                    "qualname": "gradient",
                    "docstring": "Creates a function which computes the gradient of `f`.\n\nExample:\n```python\ndef loss_function(x, y):\n    prediction = f(x)\n    loss = math.l2_loss(prediction - y)\n    return loss, prediction\n\ndx = gradient(loss_function, 'x', get_output=False)(x, y)\n\n(loss, prediction), (dx, dy) = gradient(loss_function,\n                                        'x,y', get_output=True)(x, y)\n```\n\nFunctional gradients are implemented for the following backends:\n\n* PyTorch: [`torch.autograd.grad`](https://pytorch.org/docs/stable/autograd.html#torch.autograd.grad) / [`torch.autograd.backward`](https://pytorch.org/docs/stable/autograd.html#torch.autograd.backward)\n* TensorFlow: [`tf.GradientTape`](https://www.tensorflow.org/api_docs/python/tf/GradientTape)\n* Jax: [`jax.grad`](https://jax.readthedocs.io/en/latest/jax.html#jax.grad)\n\nWhen the gradient function is invoked, `f` is called with tensors that track the gradient.\nFor PyTorch, `arg.requires_grad = True` for all positional arguments of `f`.\n\nArgs:\n    f: Function to be differentiated.\n        `f` must return a floating point `Tensor` with rank zero.\n        It can return additional tensors which are treated as auxiliary data and will be returned by the gradient function if `return_values=True`.\n        All arguments for which the gradient is computed must be of dtype float or complex.\n    get_output: Whether the gradient function should also return the return values of `f`.\n    wrt: Comma-separated parameter names of `f` with respect to which the gradient should be computed.\n        If not specified, the gradient will be computed w.r.t. the first positional argument (highly discouraged).\n\nReturns:\n    Function with the same arguments as `f` that returns the value of `f`, auxiliary data and gradient of `f` if `get_output=True`, else just the gradient of `f`.",
                    "signature": "(f: Callable, wrt: str = None, get_output=True) -> Callable"
                },
                {
                    "name": "gradient",
                    "qualname": "gradient",
                    "docstring": "Creates a function which computes the gradient of `f`.\n\nExample:\n```python\ndef loss_function(x, y):\n    prediction = f(x)\n    loss = math.l2_loss(prediction - y)\n    return loss, prediction\n\ndx = gradient(loss_function, 'x', get_output=False)(x, y)\n\n(loss, prediction), (dx, dy) = gradient(loss_function,\n                                        'x,y', get_output=True)(x, y)\n```\n\nFunctional gradients are implemented for the following backends:\n\n* PyTorch: [`torch.autograd.grad`](https://pytorch.org/docs/stable/autograd.html#torch.autograd.grad) / [`torch.autograd.backward`](https://pytorch.org/docs/stable/autograd.html#torch.autograd.backward)\n* TensorFlow: [`tf.GradientTape`](https://www.tensorflow.org/api_docs/python/tf/GradientTape)\n* Jax: [`jax.grad`](https://jax.readthedocs.io/en/latest/jax.html#jax.grad)\n\nWhen the gradient function is invoked, `f` is called with tensors that track the gradient.\nFor PyTorch, `arg.requires_grad = True` for all positional arguments of `f`.\n\nArgs:\n    f: Function to be differentiated.\n        `f` must return a floating point `Tensor` with rank zero.\n        It can return additional tensors which are treated as auxiliary data and will be returned by the gradient function if `return_values=True`.\n        All arguments for which the gradient is computed must be of dtype float or complex.\n    get_output: Whether the gradient function should also return the return values of `f`.\n    wrt: Comma-separated parameter names of `f` with respect to which the gradient should be computed.\n        If not specified, the gradient will be computed w.r.t. the first positional argument (highly discouraged).\n\nReturns:\n    Function with the same arguments as `f` that returns the value of `f`, auxiliary data and gradient of `f` if `get_output=True`, else just the gradient of `f`.",
                    "signature": "(f: Callable, wrt: str = None, get_output=True) -> Callable"
                },
                {
                    "name": "imag",
                    "qualname": "imag",
                    "docstring": "Returns the imaginary part of `x`.\nIf `x` does not store complex numbers, returns a zero tensor with the same shape and dtype as this tensor.\n\nSee Also:\n    `real()`, `conjugate()`.\n\nArgs:\n    x: `Tensor` or `phiml.math.magic.PhiTreeNode` or native tensor.\n\nReturns:\n    Imaginary component of `x` if `x` is complex, zeros otherwise.",
                    "signature": "(x: ~TensorOrTree) -> ~TensorOrTree"
                },
                {
                    "name": "integrate",
                    "qualname": "integrate",
                    "docstring": "Computes *\u222b<sub>R</sub> f(x) dx<sup>d</sup>* , where *f* denotes the `Field`, *R* the `region` and *d* the number of spatial dimensions (`d=field.shape.spatial_rank`).\nDepending on the `sample` implementation for `field`, the integral may be a rough approximation.\n\nThis method is currently only implemented for `CenteredGrid`.\n\nArgs:\n    field: `Field` to integrate.\n    region: Region to integrate over.\n    **kwargs: Specify numerical scheme.\n\nReturns:\n    Integral as `phi.Tensor`",
                    "signature": "(field: phi.field._field.Field, region: phi.geom._geom.Geometry, **kwargs) -> phiml.math._tensors.Tensor"
                },
                {
                    "name": "is_finite",
                    "qualname": "is_finite",
                    "docstring": "Returns a `Tensor` or `phiml.math.magic.PhiTreeNode` matching `x` with values `True` where `x` has a finite value and `False` otherwise.",
                    "signature": "(x: ~TensorOrTree) -> ~TensorOrTree"
                },
                {
                    "name": "isfinite",
                    "qualname": "is_finite",
                    "docstring": "Returns a `Tensor` or `phiml.math.magic.PhiTreeNode` matching `x` with values `True` where `x` has a finite value and `False` otherwise.",
                    "signature": "(x: ~TensorOrTree) -> ~TensorOrTree"
                },
                {
                    "name": "jacobian",
                    "qualname": "jacobian",
                    "docstring": "Creates a function which computes the Jacobian matrix of `f`.\nFor scalar functions, consider using `gradient()` instead.\n\nExample:\n```python\ndef f(x, y):\n    prediction = f(x)\n    loss = math.l2_loss(prediction - y)\n    return loss, prediction\n\ndx = jacobian(loss_function, wrt='x', get_output=False)(x, y)\n\n(loss, prediction), (dx, dy) = jacobian(loss_function,\n                                    wrt='x,y', get_output=True)(x, y)\n```\n\nFunctional gradients are implemented for the following backends:\n\n* PyTorch: [`torch.autograd.grad`](https://pytorch.org/docs/stable/autograd.html#torch.autograd.grad) / [`torch.autograd.backward`](https://pytorch.org/docs/stable/autograd.html#torch.autograd.backward)\n* TensorFlow: [`tf.GradientTape`](https://www.tensorflow.org/api_docs/python/tf/GradientTape)\n* Jax: [`jax.grad`](https://jax.readthedocs.io/en/latest/jax.html#jax.grad)\n\nWhen the gradient function is invoked, `f` is called with tensors that track the gradient.\nFor PyTorch, `arg.requires_grad = True` for all positional arguments of `f`.\n\nArgs:\n    f: Function to be differentiated.\n        `f` must return a floating point `Tensor` with rank zero.\n        It can return additional tensors which are treated as auxiliary data and will be returned by the gradient function if `return_values=True`.\n        All arguments for which the gradient is computed must be of dtype float or complex.\n    get_output: Whether the gradient function should also return the return values of `f`.\n    wrt: Comma-separated parameter names of `f` with respect to which the gradient should be computed.\n        If not specified, the gradient will be computed w.r.t. the first positional argument (highly discouraged).\n\nReturns:\n    Function with the same arguments as `f` that returns the value of `f`, auxiliary data and Jacobian of `f` if `get_output=True`, else just the Jacobian of `f`.",
                    "signature": "(f: Callable, wrt: str = None, get_output=True) -> Callable"
                },
                {
                    "name": "jit_compile",
                    "qualname": "jit_compile",
                    "docstring": "Compiles a graph based on the function `f`.\nThe graph compilation is performed just-in-time (jit), e.g. when the returned function is called for the first time.\n\nThe traced function will compute the same result as `f` but may run much faster.\nSome checks may be disabled in the compiled function.\n\nCan be used as a decorator:\n```python\n@math.jit_compile\ndef my_function(x: math.Tensor) -> math.Tensor:\n```\n\nInvoking the returned function may invoke re-tracing / re-compiling `f` after the first call if either\n\n* it is called with a different number of arguments,\n* the tensor arguments have different dimension names or types (the dimension order also counts),\n* any `Tensor` arguments require a different backend than previous invocations,\n* `phiml.math.magic.PhiTreeNode` positional arguments do not match in non-variable properties.\n\nCompilation is implemented for the following backends:\n\n* PyTorch: [`torch.jit.trace`](https://pytorch.org/docs/stable/jit.html)\n* TensorFlow: [`tf.function`](https://www.tensorflow.org/guide/function)\n* Jax: [`jax.jit`](https://jax.readthedocs.io/en/latest/notebooks/quickstart.html#using-jit-to-speed-up-functions)\n\nJit-compilations cannot be nested, i.e. you cannot call `jit_compile()` while another function is being compiled.\nAn exception to this is `jit_compile_linear()` which can be called from within a jit-compiled function.\n\nSee Also:\n    `jit_compile_linear()`\n\nArgs:\n    f: Function to be traced.\n        All positional arguments must be of type `Tensor` or `phiml.math.magic.PhiTreeNode` returning a single `Tensor` or `phiml.math.magic.PhiTreeNode`.\n    auxiliary_args: Comma-separated parameter names of arguments that are not relevant to backpropagation.\n    forget_traces: If `True`, only remembers the most recent compiled instance of this function.\n        Upon tracing with new instance (due to changed shapes or auxiliary args), deletes the previous traces.\n\nReturns:\n    Function with similar signature and return values as `f`.",
                    "signature": "(f: Callable = None, auxiliary_args: str = '', forget_traces: bool = None) -> Callable"
                },
                {
                    "name": "jit_compile_linear",
                    "qualname": "jit_compile_linear",
                    "docstring": "Compile an optimized representation of the linear function `f`.\nFor backends that support sparse tensors, a sparse matrix will be constructed for `f`.\n\nCan be used as a decorator:\n```python\n@math.jit_compile_linear\ndef my_linear_function(x: math.Tensor) -> math.Tensor:\n```\n\nUnlike `jit_compile()`, `jit_compile_linear()` can be called during a regular jit compilation.\n\nSee Also:\n    `jit_compile()`\n\nArgs:\n    f: Function that is linear in its positional arguments.\n        All positional arguments must be of type `Tensor` and `f` must return a `Tensor`.\n    auxiliary_args: Which parameters `f` is not linear in. These arguments are treated as conditioning arguments and will cause re-tracing on change.\n    forget_traces: If `True`, only remembers the most recent compiled instance of this function.\n        Upon tracing with new instance (due to changed shapes or auxiliary args), deletes the previous traces.\n\nReturns:\n    `LinearFunction` with similar signature and return values as `f`.",
                    "signature": "(f: Callable[[~X], ~Y] = None, auxiliary_args: str = None, forget_traces: bool = None) -> 'LinearFunction[X, Y]'"
                },
                {
                    "name": "l1_loss",
                    "qualname": "l1_loss",
                    "docstring": "Computes *\u2211<sub>i</sub> ||x<sub>i</sub>||<sub>1</sub>*, summing over all non-batch dimensions.\n\nArgs:\n    x: `Tensor` or `phiml.math.magic.PhiTreeNode` or 0D or 1D native tensor.\n        For `phiml.math.magic.PhiTreeNode` objects, only value the sum over all value attributes is computed.\n    reduce: Dimensions to reduce as `DimFilter`.\n\nReturns:\n    loss: `Tensor`",
                    "signature": "(x, reduce: Union[str, Sequence, set, phiml.math._shape.Shape, Callable, NoneType] = <function non_batch at 0x000001F5FF5584A0>) -> phiml.math._tensors.Tensor"
                },
                {
                    "name": "l2_loss",
                    "qualname": "l2_loss",
                    "docstring": "Computes *\u2211<sub>i</sub> ||x<sub>i</sub>||<sub>2</sub><sup>2</sup> / 2*, summing over all non-batch dimensions.\n\nArgs:\n    x: `Tensor` or `phiml.math.magic.PhiTreeNode` or 0D or 1D native tensor.\n        For `phiml.math.magic.PhiTreeNode` objects, only value the sum over all value attributes is computed.\n    reduce: Dimensions to reduce as `DimFilter`.\n\nReturns:\n    loss: `Tensor`",
                    "signature": "(x, reduce: Union[str, Sequence, set, phiml.math._shape.Shape, Callable, NoneType] = <function non_batch at 0x000001F5FF5584A0>) -> phiml.math._tensors.Tensor"
                },
                {
                    "name": "laplace",
                    "qualname": "laplace",
                    "docstring": "Spatial Laplace operator for scalar grid.\n\nFor grids, uses a finite difference scheme specified by `order` and `implicit`.\nFor unstructured meshes, the scheme is specified via `order` and `upwind`.\n\nArgs:\n    u: n-dimensional grid or mesh.\n    axes: The second derivative along these dimensions is summed over\n    weights: (Optional) Multiply the axis terms by these factors before summation.\n        Must be a `phi.math.Tensor` or `phi.field.Field` with a single channel dimension that lists all laplace axes by name.\n    gradient: Only used by FVM at the moment. Approximate gradient of `u`, e.g. \u2207u of the previous time step.\n        If `None`, approximates the gradient as `(u_neighbor - u_self) / distance`.\n    order: Spatial order of accuracy.\n        Higher orders entail larger stencils and more computation time but result in more accurate results assuming a large enough resolution.\n        Supported: 2 explicit, 4 explicit, 6 implicit (inherited from `phi.field.laplace()`).\n        For FVM, the order is used when interpolating `v` and `prev_v` to cell faces if needed.\n    implicit: When a `Solve` object is passed, performs an implicit operation with the specified solver and tolerances.\n        Otherwise, an explicit stencil is used.\n    implicitness: specifies the size of the implicit stencil in case an implicit treatment is used\n    upwind: FVM only. Whether to use upwind interpolation.\n    correct_skew: If `True`, adds a correction term for cell skewness. This requires `gradient` to be passed.\n\nReturns:\n    laplacian field as `CenteredGrid`",
                    "signature": "(u: phi.field._field.Field, axes: Union[str, Sequence, set, phiml.math._shape.Shape, Callable, NoneType] = <function spatial at 0x000001F5FF553E20>, gradient: phi.field._field.Field = None, order=2, implicit: phiml.math._optimize.Solve = None, implicitness: int = None, weights: Union[phiml.math._tensors.Tensor, phi.field._field.Field] = None, upwind: phi.field._field.Field = None, correct_skew=True, wide_stencil=False) -> phi.field._field.Field"
                },
                {
                    "name": "mask",
                    "qualname": "mask",
                    "docstring": "Returns a `Field` that masks the inside (or non-zero values when `obj` is a grid) of a physical object.\nThe mask takes the value 1 inside the object and 0 outside.\nFor `CenteredGrid` and `StaggeredGrid`, the mask labels non-zero non-NaN entries as 1 and all other values as 0\n\nReturns:\n    `Grid` type or `PointCloud`",
                    "signature": "(obj: phi.field._field.Field) -> phi.field._field.Field"
                },
                {
                    "name": "maximum",
                    "qualname": "maximum",
                    "docstring": "Element-wise maximum.\nOne of the given fields needs to be an instance of `Field` and the the result will be sampled at the corresponding points.\nIf both are `Fields` but have different points, `f1` takes priority.\n\nArgs:\n    f1: `Field` or `Geometry` or constant.\n    f2: `Field` or `Geometry` or constant.\n\nReturns:\n    `Field`",
                    "signature": "(f1: phi.field._field.Field, f2: phi.field._field.Field)"
                },
                {
                    "name": "mean",
                    "qualname": "mean",
                    "docstring": "Computes the mean value by reducing all spatial / instance dimensions.\n\nArgs:\n    field: `Field`\n\nReturns:\n    `phi.Tensor`",
                    "signature": "(field: phi.field._field.Field, dim=<function <lambda> at 0x000001F5FFB8ACA0>) -> phiml.math._tensors.Tensor"
                },
                {
                    "name": "minimize",
                    "qualname": "minimize",
                    "docstring": "Finds a minimum of the scalar function *f(x)*.\nThe `method` argument of `solve` determines which optimizer is used.\nAll optimizers supported by `scipy.optimize.minimize` are supported,\nsee https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.minimize.html .\nAdditionally a gradient descent solver with adaptive step size can be used with `method='GD'`.\n\n`math.minimize()` is limited to backends that support `jacobian()`, i.e. PyTorch, TensorFlow and Jax.\n\nTo obtain additional information about the performed solve, use a `SolveTape`.\n\nSee Also:\n    `solve_nonlinear()`.\n\nArgs:\n    f: Function whose output is subject to minimization.\n        All positional arguments of `f` are optimized and must be `Tensor` or `phiml.math.magic.PhiTreeNode`.\n        If `solve.x0` is a `tuple` or `list`, it will be passed to *f* as varargs, `f(*x0)`.\n        To minimize a subset of the positional arguments, define a new (lambda) function depending only on those.\n        The first return value of `f` must be a scalar float `Tensor` or `phiml.math.magic.PhiTreeNode`.\n    solve: `Solve` object to specify method type, parameters and initial guess for `x`.\n\nReturns:\n    x: solution, the minimum point `x`.\n\nRaises:\n    NotConverged: If the desired accuracy was not be reached within the maximum number of iterations.\n    Diverged: If the optimization failed prematurely.",
                    "signature": "(f: Callable[[~X], ~Y], solve: phiml.math._optimize.Solve[~X, ~Y]) -> ~X"
                },
                {
                    "name": "minimum",
                    "qualname": "minimum",
                    "docstring": "Element-wise minimum.\nOne of the given fields needs to be an instance of `Field` and the the result will be sampled at the corresponding points.\nIf both are `Fields` but have different points, `f1` takes priority.\n\nArgs:\n    f1: `Field` or `Geometry` or constant.\n    f2: `Field` or `Geometry` or constant.\n\nReturns:\n    `Field`",
                    "signature": "(f1: phi.field._field.Field, f2: phi.field._field.Field)"
                },
                {
                    "name": "native_call",
                    "qualname": "native_call",
                    "docstring": "Similar to `phi.math.native_call()`.\n\nArgs:\n    f: Function to be called on native tensors of `inputs.values`.\n        The function output must have the same dimension layout as the inputs and the batch size must be identical.\n    *inputs: `Field` or `phi.Tensor` instances.\n    extrapolation: (Optional) Extrapolation of the output field. If `None`, uses the extrapolation of the first input field.\n\nReturns:\n    `Field` matching the first `Field` in `inputs`.",
                    "signature": "(f, *inputs, channels_last=None, channel_dim='vector', extrapolation=None) -> Union[phi.field._field.Field, phiml.math._tensors.Tensor]"
                },
                {
                    "name": "normalize",
                    "qualname": "normalize",
                    "docstring": "Multiplies the values of `field` so that its sum matches the source.",
                    "signature": "(field: phi.field._field.Field, norm: phi.field._field.Field, epsilon=1e-05)"
                },
                {
                    "name": "pack_dims",
                    "qualname": "pack_dims",
                    "docstring": "Currently only supports grids and non-spatial dimensions.\n\nSee Also:\n    `phi.math.pack_dims()`.\n\nArgs:\n    field: `Field`\n\nReturns:\n    `Field` of same type as `field`.",
                    "signature": "(field: phi.field._field.Field, dims: phiml.math._shape.Shape, packed_dim: phiml.math._shape.Shape, pos: int = None) -> phi.field._field.Field"
                },
                {
                    "name": "pad",
                    "qualname": "pad",
                    "docstring": "Pads a `Grid` using its extrapolation.\n\nUnlike `phi.math.pad()`, this function also affects the `bounds` of the grid, changing its size and origin depending on `widths`.\n\nArgs:\n    grid: `CenteredGrid` or `StaggeredGrid`\n    widths: Either `int` or `(lower, upper)` to pad the same number of cells in all spatial dimensions\n        or `dict` mapping dimension names to `(lower, upper)`.\n\nReturns:\n    `Grid` of the same type as `grid`",
                    "signature": "(grid: phi.field._field.Field, widths: Union[int, tuple, list, dict]) -> phi.field._field.Field"
                },
                {
                    "name": "read",
                    "qualname": "read",
                    "docstring": "Loads a previously saved `Field` from disc.\n\nSee Also:\n    `write()`.\n\nArgs:\n    file: Single file as `str` or `Tensor` of string type.\n        If `file` is a tensor, all contained files are loaded an stacked according to the dimensions of `file`.\n    convert_to_backend: Whether to convert the read data to the data format of the default backend, e.g. TensorFlow tensors.\n\nReturns:\n    Loaded `Field`.",
                    "signature": "(file: Union[str, phiml.math._tensors.Tensor], convert_to_backend=True) -> phi.field._field.Field"
                },
                {
                    "name": "real",
                    "qualname": "real",
                    "docstring": "See Also:\n    `imag()`, `conjugate()`.\n\nArgs:\n    x: `Tensor` or `phiml.math.magic.PhiTreeNode` or native tensor.\n\nReturns:\n    Real component of `x`.",
                    "signature": "(x: ~TensorOrTree) -> ~TensorOrTree"
                },
                {
                    "name": "reduce_sample",
                    "qualname": "reduce_sample",
                    "docstring": "Alias for `sample()` with `dot_face_normal=field.geometry`.",
                    "signature": "(field: Union[phi.field._field.Field, phi.geom._geom.Geometry, phi.field._field.FieldInitializer, Callable], geometry: phi.geom._geom.Geometry, **kwargs) -> phiml.math._tensors.Tensor"
                },
                {
                    "name": "resample",
                    "qualname": "resample",
                    "docstring": "Samples a `Field`, `Geometry` or value at the sample points of the field `to`.\nThe result will approximate `value` on the data structure of `to`.\nUnlike `sample()`, this method returns a `Field` object, not a `Tensor`.\n\nAliases:\n    `value.at(to)`, (and the deprecated `value @ to`).\n\nSee Also:\n    `sample()`, `reduce_sample()`, `Field.at()`, [Resampling overview](https://tum-pbs.github.io/PhiFlow/Fields.html#resampling-fields).\n\nArgs:\n    value: Object containing values to resample.\n        This can be\n    to: `Field` (`CenteredGrid`, `StaggeredGrid` or `PointCloud`) object defining the sample points.\n        The current values of `to` are ignored.\n    keep_boundary: Only available if `self` is a `Field`.\n        If True, the resampled field will inherit the extrapolation from `self` instead of `representation`.\n        This can result in non-compatible value tensors for staggered grids where the tensor size depends on the extrapolation type.\n    **kwargs: Sampling arguments, e.g. to specify the numerical scheme.\n        By default, linear interpolation is used.\n        Grids also support 6th order implicit sampling at mid-points.\n\nReturns:\n    Field object of same type as `representation`\n\nExamples:\n    >>> grid = CenteredGrid(x=64, y=32)\n    >>> field.resample(Noise(), to=grid)\n    CenteredGrid[(x\u02e2=64, y\u02e2=32), size=(x=64, y=32), extrapolation=float64 0.0]\n    >>> field.resample(1, to=grid)\n    CenteredGrid[(x\u02e2=64, y\u02e2=32), size=(x=64, y=32), extrapolation=float64 0.0]\n    >>> field.resample(Box(x=1, y=2), to=grid)\n    CenteredGrid[(x\u02e2=64, y\u02e2=32), size=(x=64, y=32), extrapolation=float64 0.0]\n    >>> field.resample(grid, to=grid) == grid\n    True",
                    "signature": "(value: Union[phi.field._field.Field, phi.geom._geom.Geometry, phiml.math._tensors.Tensor, float, phi.field._field.FieldInitializer], to: Union[phi.field._field.Field, phi.geom._geom.Geometry], keep_boundary=False, **kwargs)"
                },
                {
                    "name": "round",
                    "qualname": "round_",
                    "docstring": "Rounds the `Tensor` or `phiml.math.magic.PhiTreeNode` `x` to the closest integer.",
                    "signature": "(x: ~TensorOrTree) -> ~TensorOrTree"
                },
                {
                    "name": "safe_mul",
                    "qualname": "safe_mul",
                    "docstring": "See `phiml.math.safe_mul()`",
                    "signature": "(x, y)"
                },
                {
                    "name": "sample",
                    "qualname": "sample",
                    "docstring": "Computes the field value inside the volume of the (batched) `geometry`.\n\nThe field value may be determined by integrating over the volume, sampling the central value or any other way.\n\nThe batch dimensions of `geometry` are matched with this field.\nThe `geometry` must not share any channel dimensions with this field.\nSpatial dimensions of `geometry` can be used to sample a grid of geometries.\n\nSee Also:\n    `Field.at()`, [Resampling overview](https://tum-pbs.github.io/PhiFlow/Fields.html#resampling-fields).\n\nArgs:\n    field: Source `Field` to sample.\n    geometry: Single or batched `phi.geom.Geometry` or `Field` or location `Tensor`.\n        When passing a `Field`, its `elements` are used as sample points.\n        When passing a vector-valued `Tensor`, a `Point` geometry will be created.\n    at: One of 'center', 'face', 'vertex'\n    boundary: Target extrapolation.\n    dot_face_normal: If not `None` and , `field` is a vector field and `at=='face'`, the dot product between sampled field vectors and the face normals is returned instead.\n    **kwargs: Sampling arguments, e.g. to specify the numerical scheme.\n        By default, linear interpolation is used.\n        Grids also support 6th order implicit sampling at mid-points.\n\nReturns:\n    Sampled values as a `phi.math.Tensor`",
                    "signature": "(field: Union[phi.field._field.Field, phi.geom._geom.Geometry, phi.field._field.FieldInitializer, Callable], geometry: phi.geom._geom.Geometry, at: str = 'center', boundary: Union[phiml.math.extrapolation.Extrapolation, phiml.math._tensors.Tensor, numbers.Number] = None, dot_face_normal: Optional[phi.geom._geom.Geometry] = None, **kwargs) -> phiml.math._tensors.Tensor"
                },
                {
                    "name": "shift",
                    "qualname": "shift",
                    "docstring": "Wraps :func:`math.shift` for CenteredGrid.\n\nArgs:\n  grid: CenteredGrid: \n  offsets: tuple: \n  stack_dim:  (Default value = 'shift')",
                    "signature": "(grid: phi.field._field.Field, offsets: tuple, stack_dim: Optional[phiml.math._shape.Shape] = (shift\u1d9c=None), dims=<function spatial at 0x000001F5FF553E20>, pad=True)"
                },
                {
                    "name": "sign",
                    "qualname": "sign",
                    "docstring": "The sign of positive numbers is 1 and -1 for negative numbers.\nThe sign of 0 is undefined.\n\nArgs:\n    x: `Tensor` or `phiml.math.magic.PhiTreeNode`\n\nReturns:\n    `Tensor` or `phiml.math.magic.PhiTreeNode` matching `x`.",
                    "signature": "(x: ~TensorOrTree) -> ~TensorOrTree"
                },
                {
                    "name": "sin",
                    "qualname": "sin",
                    "docstring": "Computes *sin(x)* of the `Tensor` or `phiml.math.magic.PhiTreeNode` `x`.",
                    "signature": "(x: ~TensorOrTree) -> ~TensorOrTree"
                },
                {
                    "name": "solve_linear",
                    "qualname": "solve_linear",
                    "docstring": "Solves the system of linear equations *f(x) = y* and returns *x*.\nThis method will use the solver specified in `solve`.\nThe following method identifiers are supported by all backends:\n\n* `'auto'`: Automatically choose a solver\n* `'CG'`: Conjugate gradient, only for symmetric and positive definite matrices.\n* `'CG-adaptive'`: Conjugate gradient with adaptive step size, only for symmetric and positive definite matrices.\n* `'biCG'` or `'biCG-stab(0)'`: Biconjugate gradient\n* `'biCG-stab'` or `'biCG-stab(1)'`: Biconjugate gradient stabilized, first order\n* `'biCG-stab(2)'`, `'biCG-stab(4)'`, ...: Biconjugate gradient stabilized, second or higher order\n* `'scipy-direct'`: SciPy direct solve always run oh the CPU using `scipy.sparse.linalg.spsolve`.\n* `'scipy-CG'`, `'scipy-GMres'`, `'scipy-biCG'`, `'scipy-biCG-stab'`, `'scipy-CGS'`, `'scipy-QMR'`, `'scipy-GCrotMK'`, `'scipy-lsqr'`: SciPy iterative solvers always run oh the CPU, both in eager execution and JIT mode.\n\nFor maximum performance, compile `f` using `jit_compile_linear()` beforehand.\nThen, an optimized representation of `f` (such as a sparse matrix) will be used to solve the linear system.\n\n**Caution:** The matrix construction may potentially be performed each time `solve_linear` is called if auxiliary arguments change.\nTo prevent this, jit-compile the function that makes the call to `solve_linear`.\n\nTo obtain additional information about the performed solve, perform the solve within a `SolveTape` context.\nThe used implementation can be obtained as `SolveInfo.method`.\n\nThe gradient of this operation will perform another linear solve with the parameters specified by `Solve.gradient_solve`.\n\nSee Also:\n    `solve_nonlinear()`, `jit_compile_linear()`.\n\nArgs:\n    f: One of the following:\n\n        * Linear function with `Tensor` or `phiml.math.magic.PhiTreeNode` first parameter and return value. `f` can have additional auxiliary arguments and return auxiliary values.\n        * Dense matrix (`Tensor` with at least one dual dimension)\n        * Sparse matrix (Sparse `Tensor` with at least one dual dimension)\n        * Native tensor (not yet supported)\n\n    y: Desired output of `f(x)` as `Tensor` or `phiml.math.magic.PhiTreeNode`.\n    solve: `Solve` object specifying optimization method, parameters and initial guess for `x`.\n    *f_args: Positional arguments to be passed to `f` after `solve.x0`. These arguments will not be solved for.\n        Supports vararg mode or pass all arguments as a `tuple`.\n    f_kwargs: Additional keyword arguments to be passed to `f`.\n        These arguments are treated as auxiliary arguments and can be of any type.\n\nReturns:\n    x: solution of the linear system of equations `f(x) = y` as `Tensor` or `phiml.math.magic.PhiTreeNode`.\n\nRaises:\n    NotConverged: If the desired accuracy was not be reached within the maximum number of iterations.\n    Diverged: If the solve failed prematurely.",
                    "signature": "(f: Union[Callable[[~X], ~Y], phiml.math._tensors.Tensor], y: ~Y, solve: phiml.math._optimize.Solve[~X, ~Y], *f_args, grad_for_f=False, f_kwargs: dict = None, **f_kwargs_) -> ~X"
                },
                {
                    "name": "solve_nonlinear",
                    "qualname": "solve_nonlinear",
                    "docstring": "Solves the non-linear equation *f(x) = y* by minimizing the norm of the residual.\n\nThis method is limited to backends that support `jacobian()`, currently PyTorch, TensorFlow and Jax.\n\nTo obtain additional information about the performed solve, use a `SolveTape`.\n\nSee Also:\n    `minimize()`, `solve_linear()`.\n\nArgs:\n    f: Function whose output is optimized to match `y`.\n        All positional arguments of `f` are optimized and must be `Tensor` or `phiml.math.magic.PhiTreeNode`.\n        The output of `f` must match `y`.\n    y: Desired output of `f(x)` as `Tensor` or `phiml.math.magic.PhiTreeNode`.\n    solve: `Solve` object specifying optimization method, parameters and initial guess for `x`.\n\nReturns:\n    x: Solution fulfilling `f(x) = y` within specified tolerance as `Tensor` or `phiml.math.magic.PhiTreeNode`.\n\nRaises:\n    NotConverged: If the desired accuracy was not be reached within the maximum number of iterations.\n    Diverged: If the solve failed prematurely.",
                    "signature": "(f: Callable, y, solve: phiml.math._optimize.Solve) -> phiml.math._tensors.Tensor"
                },
                {
                    "name": "spatial_gradient",
                    "qualname": "spatial_gradient",
                    "docstring": "Finite difference spatial_gradient.\n\nThis function can operate in two modes:\n\n* `type=CenteredGrid` approximates the spatial_gradient at cell centers using central differences\n* `type=StaggeredGrid` computes the spatial_gradient at face centers of neighbouring cells\n\nArgs:\n    field: centered grid of any number of dimensions (scalar field, vector field, tensor field)\n    boundary: Boundary conditions of the gradient field.\n    at: Either `'face'` or `'center'`\n    dims: Along which dimensions to compute the spatial gradient. Only supported when `type==CenteredGrid`.\n    stack_dim: Dimension to be added. This dimension lists the spatial_gradient w.r.t. the spatial dimensions.\n        The `field` must not have a dimension of the same name.\n    order: Spatial order of accuracy.\n        Higher orders entail larger stencils and more computation time but result in more accurate results assuming a large enough resolution.\n        Supported: 2 explicit, 4 explicit, 6 implicit.\n    implicit: When a `Solve` object is passed, performs an implicit operation with the specified solver and tolerances.\n        Otherwise, an explicit stencil is used.\n    implicitness: specifies the size of the implicit stencil in case an implicit treatment is used\n    gradient_extrapolation: Alias for `boundary`.\n    scheme: For unstructured meshes only. Currently only `'green-gauss'` is supported.\n    upwind: For unstructured meshes only. Whether to use upwind interpolation.\n\nReturns:\n    spatial_gradient field of type `type`.",
                    "signature": "(field: phi.field._field.Field, boundary: phiml.math.extrapolation.Extrapolation = None, at: str = 'center', dims: Union[str, Sequence, set, phiml.math._shape.Shape, Callable, NoneType] = <function spatial at 0x000001F5FF553E20>, stack_dim: Union[phiml.math._shape.Shape, str] = (vector\u1d9c=None), order=2, implicit: phiml.math._optimize.Solve = None, implicitness: int = None, scheme=None, upwind: phi.field._field.Field = None, gradient_extrapolation: phiml.math.extrapolation.Extrapolation = None)"
                },
                {
                    "name": "sqrt",
                    "qualname": "sqrt",
                    "docstring": "Computes *sqrt(x)* of the `Tensor` or `phiml.math.magic.PhiTreeNode` `x`.",
                    "signature": "(x: ~TensorOrTree) -> ~TensorOrTree"
                },
                {
                    "name": "stack",
                    "qualname": "stack",
                    "docstring": "Stacks the given `Field`s along `dim`.\n\nSee Also:\n    `concat()`.\n\nArgs:\n    fields: List of matching `Field` instances.\n    dim: Stack dimension as `Shape`. Size is ignored.\n    dim_bounds: `Box` defining the physical size for `dim`.\n\nReturns:\n    `Field` matching stacked fields.",
                    "signature": "(fields: Sequence[phi.field._field.Field], dim: phiml.math._shape.Shape, dim_bounds: phi.geom._box.Box = None)"
                },
                {
                    "name": "stagger",
                    "qualname": "stagger",
                    "docstring": "Creates a new grid by evaluating `face_function` given two neighbouring cells.\nOne layer of missing cells is inferred from the extrapolation.\n\nThis method returns a Field of type `type` which must be either StaggeredGrid or CenteredGrid.\nWhen returning a StaggeredGrid, the new values are sampled at the faces of neighbouring cells.\nWhen returning a CenteredGrid, the new grid has the same resolution as `field`.\n\nArgs:\n    field: Grid\n    face_function: function mapping (value1: Tensor, value2: Tensor) -> center_value: Tensor\n    boundary: extrapolation mode of the returned grid. Has no effect on the values.\n    at: Where the result should be sampled, one of 'face', 'center'\n    dims: Which dimensions to stagger. Defaults to all spatial axes.\n\nReturns:\n    Grid sampled either at centers or faces depending on `at`.",
                    "signature": "(field: phi.field._field.Field, face_function: Callable, boundary: float, at='face', dims=<function spatial at 0x000001F5FF553E20>)"
                },
                {
                    "name": "stop_gradient",
                    "qualname": "stop_gradient",
                    "docstring": "Disables gradients for the given tensor.\nThis may switch off the gradients for `x` itself or create a copy of `x` with disabled gradients.\n\nImplementations:\n\n* PyTorch: [`x.detach()`](https://pytorch.org/docs/stable/autograd.html#torch.Tensor.detach)\n* TensorFlow: [`tf.stop_gradient`](https://www.tensorflow.org/api_docs/python/tf/stop_gradient)\n* Jax: [`jax.lax.stop_gradient`](https://jax.readthedocs.io/en/latest/_autosummary/jax.lax.stop_gradient.html)\n\nArgs:\n    x: `Tensor` or `phiml.math.magic.PhiTreeNode` for which gradients should be disabled.\n\nReturns:\n    Copy of `x`.",
                    "signature": "(x)"
                },
                {
                    "name": "support",
                    "qualname": "support",
                    "docstring": "Returns the points at which the field values are non-zero.\n\nArgs:\n    field: `Field`\n    list_dim: Dimension to list the non-zero values.\n\nReturns:\n    `Tensor` with shape `(list_dim, vector)`",
                    "signature": "(field: phi.field._field.Field, list_dim: phiml.math._shape.Shape = (nonzero\u2071=None)) -> phiml.math._tensors.Tensor"
                },
                {
                    "name": "to_float",
                    "qualname": "to_float",
                    "docstring": "Converts the given tensor to floating point format with the currently specified precision.\n\nThe precision can be set globally using `math.set_global_precision()` and locally using `with math.precision()`.\n\nSee the documentation at https://tum-pbs.github.io/PhiML/Data_Types.html\n\nSee Also:\n    `cast()`.\n\nArgs:\n    x: `Tensor` or `phiml.math.magic.PhiTreeNode` to convert\n\nReturns:\n    `Tensor` or `phiml.math.magic.PhiTreeNode` matching `x`.",
                    "signature": "(x: ~TensorOrTree) -> ~TensorOrTree"
                },
                {
                    "name": "to_int32",
                    "qualname": "to_int32",
                    "docstring": "Converts the `Tensor` or `phiml.math.magic.PhiTreeNode` `x` to 32-bit integer.",
                    "signature": "(x: ~TensorOrTree) -> ~TensorOrTree"
                },
                {
                    "name": "to_int64",
                    "qualname": "to_int64",
                    "docstring": "Converts the `Tensor` or `phiml.math.magic.PhiTreeNode` `x` to 64-bit integer.",
                    "signature": "(x: ~TensorOrTree) -> ~TensorOrTree"
                },
                {
                    "name": "unstack",
                    "qualname": "unstack",
                    "docstring": "Un-stacks a `Sliceable` along one or multiple dimensions.\n\nIf multiple dims are given, the order of elements will be according to the dimension order in `dim`, i.e. elements along the last dimension will be neighbors in the returned `tuple`.\nIf no dimension is given or none of the given dims exists on `value`, returns a list containing only `value`.\n\nSee Also:\n    `phiml.math.slice`.\n\nArgs:\n    value: `phiml.math.magic.Shapable`, such as `phiml.math.Tensor`\n    dim: Dimensions as `Shape` or comma-separated `str` or dimension type, i.e. `channel`, `spatial`, `instance`, `batch`.\n    expand: If `True`, `dim` must be a `Shape` and the returned tuple will have length `dim.volume`. Otherwise, only existing dims are unstacked.\n\nReturns:\n    `tuple` of objects matching the type of `value`.\n\nExamples:\n    >>> unstack(expand(0, spatial(x=5)), 'x')\n    (0.0, 0.0, 0.0, 0.0, 0.0)",
                    "signature": "(value: ~MagicType, dim: Union[str, Sequence, set, phiml.math._shape.Shape, Callable, NoneType], expand=False) -> Tuple[~MagicType, ...]"
                },
                {
                    "name": "upsample2x",
                    "qualname": "upsample2x",
                    "docstring": "Increases the number of sample points by a factor of 2 in each spatial dimension.\nThe new values are determined via linear interpolation.\n\nSee Also:\n    `downsample2x()`.\n\nArgs:\n    grid: `CenteredGrid` or `StaggeredGrid`.\n\nReturns:\n    `Grid` of same type as `grid`.",
                    "signature": "(grid: phi.field._field.Field) -> phi.field._field.Field"
                },
                {
                    "name": "vec_abs",
                    "qualname": "vec_length",
                    "docstring": "See `phi.math.vec_abs()`",
                    "signature": "(field: phi.field._field.Field)"
                },
                {
                    "name": "vec_length",
                    "qualname": "vec_length",
                    "docstring": "See `phi.math.vec_abs()`",
                    "signature": "(field: phi.field._field.Field)"
                },
                {
                    "name": "vec_squared",
                    "qualname": "vec_squared",
                    "docstring": "See `phi.math.vec_squared()`",
                    "signature": "(field: phi.field._field.Field)"
                },
                {
                    "name": "where",
                    "qualname": "where",
                    "docstring": "Element-wise where operation.\nPicks the value of `field_true` where `mask=1 / True` and the value of `field_false` where `mask=0 / False`.\n\nThe fields are automatically resampled if necessary, preferring the sample points of `mask`.\nAt least one of the arguments must be a `Field`.\n\nArgs:\n    mask: `Field` or `Geometry` object.\n    field_true: `Field`\n    field_false: `Field`\n\nReturns:\n    `Field`",
                    "signature": "(mask: phi.field._field.Field, field_true: phi.field._field.Field, field_false: phi.field._field.Field) -> phi.field._field.Field"
                },
                {
                    "name": "write",
                    "qualname": "write",
                    "docstring": "Writes a field to disc using a NumPy file format.\nDepending on `file`, the data may be split up into multiple files.\n\nAll characteristics of the field are serialized so that it can be fully restored using `read()`.\n\nSee Also:\n    `read()`\n\nArgs:\n    field: Field to be saved.\n    file: Single file as `str` or `Tensor` of string type.\n        If `file` is a tensor, the dimensions of `field` are matched to the dimensions of `file`.\n        Dimensions of `file` that are missing in `field` result in data duplication.\n        Dimensions of `field` that are missing in `file` result in larger files.",
                    "signature": "(field: phi.field._field.Field, file: Union[str, phiml.math._tensors.Tensor])"
                }
            ],
            "classes": [
                {
                    "name": "AngularVelocity",
                    "qualname": "AngularVelocity",
                    "docstring": "Model of a single vortex or set of vortices.\nThe falloff of the velocity magnitude can be controlled.\n\nWithout a specified falloff, the velocity increases linearly with the distance from the vortex center.\nThis is the case with rotating rigid bodies, for example.",
                    "signature": "(location: Union[phiml.math._tensors.Tensor, tuple, list, numbers.Number], strength: Union[phiml.math._tensors.Tensor, numbers.Number] = 1.0, falloff: Callable = None)",
                    "type": "class",
                    "methods": []
                },
                {
                    "name": "Field",
                    "qualname": "Field",
                    "docstring": "A `Field` represents a discretized physical quantity (like temperature field or velocity field).\nThe sample points and their relation are encoded in the `geometry` property and the corresponding values are stored as one `Tensor` in `values`.\nThe boundary conditions and values outside the geometry are determined by `boundary`.\n\nExamples:\n    Create a periodic 2D grid, initialized via noise fluctuations.\n    >>> Field(UniformGrid(x=32, y=32), values=Noise(), boundary=PERIODIC)\n\n    Create a field on an unstructured mesh loaded from a .gmsh file\n    >>> mesh = phi.geom.load_gmsh('cylinder.msh', ('y-', 'x+', 'y+', 'x-', 'cyl+', 'cyl-'))\n    >>> Field(mesh, values=vec(x=1, y=0), boundary={'x': ZERO_GRADIENT, 'y': 0, 'cyl': 0})\n\n    Create two cubes and compute a scalar values for each.\n    >>> Field(Cuboid(vec(x=[0, 2], y=0), x=1, y=1), values=lambda x,y: x)\n\nSee the `phi.field` module documentation at https://tum-pbs.github.io/PhiFlow/Fields.html",
                    "signature": "(geometry: Union[phi.geom._geom.Geometry, phiml.math._tensors.Tensor], values: Union[phiml.math._tensors.Tensor, numbers.Number, bool, Callable, phi.field._field.FieldInitializer, phi.geom._geom.Geometry, ForwardRef('Field')], boundary: Union[numbers.Number, phiml.math.extrapolation.Extrapolation, ForwardRef('Field'), dict] = 0.0, variable_attrs=('values',), value_attrs=('values',), **sampling_kwargs)",
                    "type": "class",
                    "methods": [
                        {
                            "name": "as_boundary",
                            "qualname": "Field.as_boundary",
                            "docstring": "Returns an `Extrapolation` representing this 'Field''s values as a Dirichlet (constant) boundary.\nIf this `Field` encloses the required boundaries, its values will be interpolated to the required boundaries.\nIf boundaries outside of this `Field`'s sampled domain are required, this `Field`'s boundary conditions will be applied to determine the boundary values.\n\nReturns:\n    `Extrapolation`",
                            "signature": "(self) -> phiml.math.extrapolation.Extrapolation"
                        },
                        {
                            "name": "as_points",
                            "qualname": "Field.as_points",
                            "docstring": "Returns this field as a PointCloud.\nThis replaces the `Field.geometry` with a `phi.geom.Point` instance while leaving the sample points unchanged.\n\nSee Also:\n    `Field.as_spheres()`.\n\nArgs:\n    list_dim: If not `None`, packs spatial, instance and dual dims.\n        Defaults to `instance('elements')`.\n\nReturns:\n    `Field` with same values and boundaries but `Point` geometry.",
                            "signature": "(self, list_dim: Optional[phiml.math._shape.Shape] = (elements\u2071=None)) -> 'Field'"
                        },
                        {
                            "name": "as_spheres",
                            "qualname": "Field.as_spheres",
                            "docstring": "Returns this field as a PointCloud with spherical / circular elements, preserving element volumes.\nThis replaces the `Field.geometry` with a `phi.geom.Sphere` instance while leaving the sample points unchanged.\n\nSee Also:\n    `Field.as_points()`.\n\nArgs:\n    list_dim: If not `None`, packs spatial, instance and dual dims.\n        Defaults to `instance('elements')`.\n\nReturns:\n    `Field` with same values and boundaries but `Sphere` geometry.",
                            "signature": "(self, list_dim: Optional[phiml.math._shape.Shape] = (elements\u2071=None)) -> 'Field'"
                        },
                        {
                            "name": "at",
                            "qualname": "Field.at",
                            "docstring": "Short for `resample(self, representation)`\n\nSee Also\n    `resample()`.\n\nReturns:\n    Field object of same type as `representation`",
                            "signature": "(self, representation: Union[ForwardRef('Field'), phi.geom._geom.Geometry], keep_boundary=False, **kwargs) -> 'Field'"
                        },
                        {
                            "name": "at_centers",
                            "qualname": "Field.at_centers",
                            "docstring": "Interpolates the values to the cell centers.\n\nSee Also:\n    `Field.at_faces()`, `Field.at()`, `resample`.\n\nArgs:\n    **kwargs: Sampling arguments.\n\nReturns:\n    `CenteredGrid` sampled at cell centers.",
                            "signature": "(self, **kwargs) -> 'Field'"
                        },
                        {
                            "name": "at_faces",
                            "qualname": "Field.at_faces",
                            "docstring": "",
                            "signature": "(self, boundary=None, **kwargs) -> 'Field'"
                        },
                        {
                            "name": "closest_values",
                            "qualname": "Field.closest_values",
                            "docstring": "Sample the closest grid point values of this field at the world-space locations (in physical units) given by `points`.\nPoints must have a single channel dimension named `vector`.\nIt may additionally contain any number of batch and spatial dimensions, all treated as batch dimensions.\n\nArgs:\n    points: world-space locations\n\nReturns:\n    Closest grid point values as a `Tensor`.\n    For each dimension, the grid points immediately left and right of the sample points are evaluated.\n    For each point in `points`, a *2^d* cube of points is determined where *d* is the number of spatial dimensions of this field.\n    These values are stacked along the new dimensions `'closest_<dim>'` where `<dim>` refers to the name of a spatial dimension.",
                            "signature": "(self, points: phiml.math._tensors.Tensor)"
                        },
                        {
                            "name": "curl",
                            "qualname": "Field.curl",
                            "docstring": "Alias for `phi.field.curl`",
                            "signature": "(self, at='corner')"
                        },
                        {
                            "name": "dimension",
                            "qualname": "Field.dimension",
                            "docstring": "Returns a reference to one of the dimensions of this field.\n\nThe dimension reference can be used the same way as a `Tensor` dimension reference.\nNotable properties and methods of a dimension reference are:\nindexing using `[index]`, `unstack()`, `size`, `exists`, `is_batch`, `is_spatial`, `is_channel`.\n\nA shortcut to calling this function is the syntax `field.<dim_name>` which calls `field.dimension(<dim_name>)`.\n\nArgs:\n    name: dimension name\n\nReturns:\n    dimension reference",
                            "signature": "(self, name: str)"
                        },
                        {
                            "name": "divergence",
                            "qualname": "Field.divergence",
                            "docstring": "Alias for `phi.field.divergence`",
                            "signature": "(self, order=2, implicit: phiml.math._optimize.Solve = None, upwind: 'Field' = None)"
                        },
                        {
                            "name": "downsample",
                            "qualname": "Field.downsample",
                            "docstring": "",
                            "signature": "(self, factor: int)"
                        },
                        {
                            "name": "gradient",
                            "qualname": "Field.gradient",
                            "docstring": "Alias for `phi.field.spatial_gradient`",
                            "signature": "(self, boundary: phiml.math.extrapolation.Extrapolation = None, at: str = 'center', dims: Union[str, Sequence, set, phiml.math._shape.Shape, Callable, NoneType] = <function spatial at 0x000001F5FF553E20>, stack_dim: Union[phiml.math._shape.Shape, str] = (vector\u1d9c=None), order=2, implicit: phiml.math._optimize.Solve = None, scheme=None, upwind: 'Field' = None, gradient_extrapolation: phiml.math.extrapolation.Extrapolation = None)"
                        },
                        {
                            "name": "grid_scatter",
                            "qualname": "Field.grid_scatter",
                            "docstring": "Deprecated. Use `sample` with `scatter=True` instead.",
                            "signature": "(self, *args, **kwargs)"
                        },
                        {
                            "name": "laplace",
                            "qualname": "Field.laplace",
                            "docstring": "Alias for `phi.field.laplace`",
                            "signature": "(self, axes: Union[str, Sequence, set, phiml.math._shape.Shape, Callable, NoneType] = <function spatial at 0x000001F5FF553E20>, gradient: 'Field' = None, order=2, implicit: phiml.math._optimize.Solve = None, weights: Union[phiml.math._tensors.Tensor, ForwardRef('Field')] = None, upwind: 'Field' = None, correct_skew=True)"
                        },
                        {
                            "name": "numpy",
                            "qualname": "Field.numpy",
                            "docstring": "Return the field values as `NumPy` array(s).\n\nArgs:\n    order: Dimension order as `str` or `Shape`.\n\nReturns:\n    A single NumPy array for uniform values, else a list of NumPy arrays.",
                            "signature": "(self, order: Union[str, Sequence, set, phiml.math._shape.Shape, Callable, NoneType] = None)"
                        },
                        {
                            "name": "pad",
                            "qualname": "Field.pad",
                            "docstring": "Alias for `phi.field.pad()`.\n\nPads this `Field` using its extrapolation.\n\nUnlike padding the values, this function also affects the `geometry` of the field, changing its size and origin depending on `widths`.\n\nArgs:\n    widths: Either `int` or `(lower, upper)` to pad the same number of cells in all spatial dimensions\n        or `dict` mapping dimension names to `(lower, upper)`.\n\nReturns:\n    Padded `Field`",
                            "signature": "(self, widths: Union[int, tuple, list, dict]) -> 'Field'"
                        },
                        {
                            "name": "sample",
                            "qualname": "Field.sample",
                            "docstring": "Sample the values of this `Field` at the given location or geometry.\n\nArgs:\n    where: Location `Tensor` or `Geometry` or\n    at: `'center'` or `'face'`.\n    **kwargs: Sampling arguments.\n\nReturns:\n    `Tensor`",
                            "signature": "(self, where: Union[phi.geom._geom.Geometry, ForwardRef('Field'), phiml.math._tensors.Tensor], at: str = 'center', **kwargs) -> 'Tensor'"
                        },
                        {
                            "name": "shifted",
                            "qualname": "Field.shifted",
                            "docstring": "Move the positions of this field's `geometry` by `delta`.\n\nSee Also:\n    `Field.shifted_to`.\n\nArgs:\n    delta: Shift amount for each center position of `geometry`.\n\nReturns:\n    New `Field` sampled at `geometry.center + delta`.",
                            "signature": "(self, delta: phiml.math._tensors.Tensor) -> 'Field'"
                        },
                        {
                            "name": "shifted_to",
                            "qualname": "Field.shifted_to",
                            "docstring": "Move the positions of this field's `geometry` to `positions`.\n\nSee Also:\n    `Field.shifted`.\n\nArgs:\n    position: New center positions of `geometry`.\n\nReturns:\n    New `Field` sampled at given positions.",
                            "signature": "(self, position: phiml.math._tensors.Tensor) -> 'Field'"
                        },
                        {
                            "name": "staggered_tensor",
                            "qualname": "Field.staggered_tensor",
                            "docstring": "Stacks all component grids into a single uniform `phi.math.Tensor`.\nThe individual components are padded to a common (larger) shape before being stacked.\nThe shape of the returned tensor is exactly one cell larger than the grid `resolution` in every spatial dimension.\n\nReturns:\n    Uniform `phi.math.Tensor`.",
                            "signature": "(self) -> phiml.math._tensors.Tensor"
                        },
                        {
                            "name": "to_grid",
                            "qualname": "Field.to_grid",
                            "docstring": "",
                            "signature": "(self, resolution=(), bounds=None, **resolution_)"
                        },
                        {
                            "name": "uniform_values",
                            "qualname": "Field.uniform_values",
                            "docstring": "Returns a uniform tensor containing `values`.\n\nFor periodic grids, which always have a uniform value tensor, `values' is returned directly.\nIf `values` is not uniform, it is padded as in `StaggeredGrid.staggered_tensor()`.",
                            "signature": "(self)"
                        },
                        {
                            "name": "with_boundary",
                            "qualname": "Field.with_boundary",
                            "docstring": "Returns a copy of this field with the `boundary` replaced.",
                            "signature": "(self, boundary)"
                        },
                        {
                            "name": "with_bounds",
                            "qualname": "Field.with_bounds",
                            "docstring": "Returns a copy of this field with `bounds` replaced.",
                            "signature": "(self, bounds: phi.geom._box.Box)"
                        },
                        {
                            "name": "with_elements",
                            "qualname": "Field.with_geometry",
                            "docstring": "Returns a copy of this field with `elements` replaced.",
                            "signature": "(self, elements: phi.geom._geom.Geometry)"
                        },
                        {
                            "name": "with_extrapolation",
                            "qualname": "Field.with_boundary",
                            "docstring": "Returns a copy of this field with the `boundary` replaced.",
                            "signature": "(self, boundary)"
                        },
                        {
                            "name": "with_geometry",
                            "qualname": "Field.with_geometry",
                            "docstring": "Returns a copy of this field with `elements` replaced.",
                            "signature": "(self, elements: phi.geom._geom.Geometry)"
                        },
                        {
                            "name": "with_values",
                            "qualname": "Field.with_values",
                            "docstring": "Returns a copy of this field with `values` replaced.",
                            "signature": "(self, values, **sampling_kwargs)"
                        }
                    ]
                },
                {
                    "name": "SampledField",
                    "qualname": "Field",
                    "docstring": "A `Field` represents a discretized physical quantity (like temperature field or velocity field).\nThe sample points and their relation are encoded in the `geometry` property and the corresponding values are stored as one `Tensor` in `values`.\nThe boundary conditions and values outside the geometry are determined by `boundary`.\n\nExamples:\n    Create a periodic 2D grid, initialized via noise fluctuations.\n    >>> Field(UniformGrid(x=32, y=32), values=Noise(), boundary=PERIODIC)\n\n    Create a field on an unstructured mesh loaded from a .gmsh file\n    >>> mesh = phi.geom.load_gmsh('cylinder.msh', ('y-', 'x+', 'y+', 'x-', 'cyl+', 'cyl-'))\n    >>> Field(mesh, values=vec(x=1, y=0), boundary={'x': ZERO_GRADIENT, 'y': 0, 'cyl': 0})\n\n    Create two cubes and compute a scalar values for each.\n    >>> Field(Cuboid(vec(x=[0, 2], y=0), x=1, y=1), values=lambda x,y: x)\n\nSee the `phi.field` module documentation at https://tum-pbs.github.io/PhiFlow/Fields.html",
                    "signature": "(geometry: Union[phi.geom._geom.Geometry, phiml.math._tensors.Tensor], values: Union[phiml.math._tensors.Tensor, numbers.Number, bool, Callable, phi.field._field.FieldInitializer, phi.geom._geom.Geometry, ForwardRef('Field')], boundary: Union[numbers.Number, phiml.math.extrapolation.Extrapolation, ForwardRef('Field'), dict] = 0.0, variable_attrs=('values',), value_attrs=('values',), **sampling_kwargs)",
                    "type": "class",
                    "methods": [
                        {
                            "name": "as_boundary",
                            "qualname": "Field.as_boundary",
                            "docstring": "Returns an `Extrapolation` representing this 'Field''s values as a Dirichlet (constant) boundary.\nIf this `Field` encloses the required boundaries, its values will be interpolated to the required boundaries.\nIf boundaries outside of this `Field`'s sampled domain are required, this `Field`'s boundary conditions will be applied to determine the boundary values.\n\nReturns:\n    `Extrapolation`",
                            "signature": "(self) -> phiml.math.extrapolation.Extrapolation"
                        },
                        {
                            "name": "as_points",
                            "qualname": "Field.as_points",
                            "docstring": "Returns this field as a PointCloud.\nThis replaces the `Field.geometry` with a `phi.geom.Point` instance while leaving the sample points unchanged.\n\nSee Also:\n    `Field.as_spheres()`.\n\nArgs:\n    list_dim: If not `None`, packs spatial, instance and dual dims.\n        Defaults to `instance('elements')`.\n\nReturns:\n    `Field` with same values and boundaries but `Point` geometry.",
                            "signature": "(self, list_dim: Optional[phiml.math._shape.Shape] = (elements\u2071=None)) -> 'Field'"
                        },
                        {
                            "name": "as_spheres",
                            "qualname": "Field.as_spheres",
                            "docstring": "Returns this field as a PointCloud with spherical / circular elements, preserving element volumes.\nThis replaces the `Field.geometry` with a `phi.geom.Sphere` instance while leaving the sample points unchanged.\n\nSee Also:\n    `Field.as_points()`.\n\nArgs:\n    list_dim: If not `None`, packs spatial, instance and dual dims.\n        Defaults to `instance('elements')`.\n\nReturns:\n    `Field` with same values and boundaries but `Sphere` geometry.",
                            "signature": "(self, list_dim: Optional[phiml.math._shape.Shape] = (elements\u2071=None)) -> 'Field'"
                        },
                        {
                            "name": "at",
                            "qualname": "Field.at",
                            "docstring": "Short for `resample(self, representation)`\n\nSee Also\n    `resample()`.\n\nReturns:\n    Field object of same type as `representation`",
                            "signature": "(self, representation: Union[ForwardRef('Field'), phi.geom._geom.Geometry], keep_boundary=False, **kwargs) -> 'Field'"
                        },
                        {
                            "name": "at_centers",
                            "qualname": "Field.at_centers",
                            "docstring": "Interpolates the values to the cell centers.\n\nSee Also:\n    `Field.at_faces()`, `Field.at()`, `resample`.\n\nArgs:\n    **kwargs: Sampling arguments.\n\nReturns:\n    `CenteredGrid` sampled at cell centers.",
                            "signature": "(self, **kwargs) -> 'Field'"
                        },
                        {
                            "name": "at_faces",
                            "qualname": "Field.at_faces",
                            "docstring": "",
                            "signature": "(self, boundary=None, **kwargs) -> 'Field'"
                        },
                        {
                            "name": "closest_values",
                            "qualname": "Field.closest_values",
                            "docstring": "Sample the closest grid point values of this field at the world-space locations (in physical units) given by `points`.\nPoints must have a single channel dimension named `vector`.\nIt may additionally contain any number of batch and spatial dimensions, all treated as batch dimensions.\n\nArgs:\n    points: world-space locations\n\nReturns:\n    Closest grid point values as a `Tensor`.\n    For each dimension, the grid points immediately left and right of the sample points are evaluated.\n    For each point in `points`, a *2^d* cube of points is determined where *d* is the number of spatial dimensions of this field.\n    These values are stacked along the new dimensions `'closest_<dim>'` where `<dim>` refers to the name of a spatial dimension.",
                            "signature": "(self, points: phiml.math._tensors.Tensor)"
                        },
                        {
                            "name": "curl",
                            "qualname": "Field.curl",
                            "docstring": "Alias for `phi.field.curl`",
                            "signature": "(self, at='corner')"
                        },
                        {
                            "name": "dimension",
                            "qualname": "Field.dimension",
                            "docstring": "Returns a reference to one of the dimensions of this field.\n\nThe dimension reference can be used the same way as a `Tensor` dimension reference.\nNotable properties and methods of a dimension reference are:\nindexing using `[index]`, `unstack()`, `size`, `exists`, `is_batch`, `is_spatial`, `is_channel`.\n\nA shortcut to calling this function is the syntax `field.<dim_name>` which calls `field.dimension(<dim_name>)`.\n\nArgs:\n    name: dimension name\n\nReturns:\n    dimension reference",
                            "signature": "(self, name: str)"
                        },
                        {
                            "name": "divergence",
                            "qualname": "Field.divergence",
                            "docstring": "Alias for `phi.field.divergence`",
                            "signature": "(self, order=2, implicit: phiml.math._optimize.Solve = None, upwind: 'Field' = None)"
                        },
                        {
                            "name": "downsample",
                            "qualname": "Field.downsample",
                            "docstring": "",
                            "signature": "(self, factor: int)"
                        },
                        {
                            "name": "gradient",
                            "qualname": "Field.gradient",
                            "docstring": "Alias for `phi.field.spatial_gradient`",
                            "signature": "(self, boundary: phiml.math.extrapolation.Extrapolation = None, at: str = 'center', dims: Union[str, Sequence, set, phiml.math._shape.Shape, Callable, NoneType] = <function spatial at 0x000001F5FF553E20>, stack_dim: Union[phiml.math._shape.Shape, str] = (vector\u1d9c=None), order=2, implicit: phiml.math._optimize.Solve = None, scheme=None, upwind: 'Field' = None, gradient_extrapolation: phiml.math.extrapolation.Extrapolation = None)"
                        },
                        {
                            "name": "grid_scatter",
                            "qualname": "Field.grid_scatter",
                            "docstring": "Deprecated. Use `sample` with `scatter=True` instead.",
                            "signature": "(self, *args, **kwargs)"
                        },
                        {
                            "name": "laplace",
                            "qualname": "Field.laplace",
                            "docstring": "Alias for `phi.field.laplace`",
                            "signature": "(self, axes: Union[str, Sequence, set, phiml.math._shape.Shape, Callable, NoneType] = <function spatial at 0x000001F5FF553E20>, gradient: 'Field' = None, order=2, implicit: phiml.math._optimize.Solve = None, weights: Union[phiml.math._tensors.Tensor, ForwardRef('Field')] = None, upwind: 'Field' = None, correct_skew=True)"
                        },
                        {
                            "name": "numpy",
                            "qualname": "Field.numpy",
                            "docstring": "Return the field values as `NumPy` array(s).\n\nArgs:\n    order: Dimension order as `str` or `Shape`.\n\nReturns:\n    A single NumPy array for uniform values, else a list of NumPy arrays.",
                            "signature": "(self, order: Union[str, Sequence, set, phiml.math._shape.Shape, Callable, NoneType] = None)"
                        },
                        {
                            "name": "pad",
                            "qualname": "Field.pad",
                            "docstring": "Alias for `phi.field.pad()`.\n\nPads this `Field` using its extrapolation.\n\nUnlike padding the values, this function also affects the `geometry` of the field, changing its size and origin depending on `widths`.\n\nArgs:\n    widths: Either `int` or `(lower, upper)` to pad the same number of cells in all spatial dimensions\n        or `dict` mapping dimension names to `(lower, upper)`.\n\nReturns:\n    Padded `Field`",
                            "signature": "(self, widths: Union[int, tuple, list, dict]) -> 'Field'"
                        },
                        {
                            "name": "sample",
                            "qualname": "Field.sample",
                            "docstring": "Sample the values of this `Field` at the given location or geometry.\n\nArgs:\n    where: Location `Tensor` or `Geometry` or\n    at: `'center'` or `'face'`.\n    **kwargs: Sampling arguments.\n\nReturns:\n    `Tensor`",
                            "signature": "(self, where: Union[phi.geom._geom.Geometry, ForwardRef('Field'), phiml.math._tensors.Tensor], at: str = 'center', **kwargs) -> 'Tensor'"
                        },
                        {
                            "name": "shifted",
                            "qualname": "Field.shifted",
                            "docstring": "Move the positions of this field's `geometry` by `delta`.\n\nSee Also:\n    `Field.shifted_to`.\n\nArgs:\n    delta: Shift amount for each center position of `geometry`.\n\nReturns:\n    New `Field` sampled at `geometry.center + delta`.",
                            "signature": "(self, delta: phiml.math._tensors.Tensor) -> 'Field'"
                        },
                        {
                            "name": "shifted_to",
                            "qualname": "Field.shifted_to",
                            "docstring": "Move the positions of this field's `geometry` to `positions`.\n\nSee Also:\n    `Field.shifted`.\n\nArgs:\n    position: New center positions of `geometry`.\n\nReturns:\n    New `Field` sampled at given positions.",
                            "signature": "(self, position: phiml.math._tensors.Tensor) -> 'Field'"
                        },
                        {
                            "name": "staggered_tensor",
                            "qualname": "Field.staggered_tensor",
                            "docstring": "Stacks all component grids into a single uniform `phi.math.Tensor`.\nThe individual components are padded to a common (larger) shape before being stacked.\nThe shape of the returned tensor is exactly one cell larger than the grid `resolution` in every spatial dimension.\n\nReturns:\n    Uniform `phi.math.Tensor`.",
                            "signature": "(self) -> phiml.math._tensors.Tensor"
                        },
                        {
                            "name": "to_grid",
                            "qualname": "Field.to_grid",
                            "docstring": "",
                            "signature": "(self, resolution=(), bounds=None, **resolution_)"
                        },
                        {
                            "name": "uniform_values",
                            "qualname": "Field.uniform_values",
                            "docstring": "Returns a uniform tensor containing `values`.\n\nFor periodic grids, which always have a uniform value tensor, `values' is returned directly.\nIf `values` is not uniform, it is padded as in `StaggeredGrid.staggered_tensor()`.",
                            "signature": "(self)"
                        },
                        {
                            "name": "with_boundary",
                            "qualname": "Field.with_boundary",
                            "docstring": "Returns a copy of this field with the `boundary` replaced.",
                            "signature": "(self, boundary)"
                        },
                        {
                            "name": "with_bounds",
                            "qualname": "Field.with_bounds",
                            "docstring": "Returns a copy of this field with `bounds` replaced.",
                            "signature": "(self, bounds: phi.geom._box.Box)"
                        },
                        {
                            "name": "with_elements",
                            "qualname": "Field.with_geometry",
                            "docstring": "Returns a copy of this field with `elements` replaced.",
                            "signature": "(self, elements: phi.geom._geom.Geometry)"
                        },
                        {
                            "name": "with_extrapolation",
                            "qualname": "Field.with_boundary",
                            "docstring": "Returns a copy of this field with the `boundary` replaced.",
                            "signature": "(self, boundary)"
                        },
                        {
                            "name": "with_geometry",
                            "qualname": "Field.with_geometry",
                            "docstring": "Returns a copy of this field with `elements` replaced.",
                            "signature": "(self, elements: phi.geom._geom.Geometry)"
                        },
                        {
                            "name": "with_values",
                            "qualname": "Field.with_values",
                            "docstring": "Returns a copy of this field with `values` replaced.",
                            "signature": "(self, values, **sampling_kwargs)"
                        }
                    ]
                },
                {
                    "name": "Grid",
                    "qualname": "Field",
                    "docstring": "A `Field` represents a discretized physical quantity (like temperature field or velocity field).\nThe sample points and their relation are encoded in the `geometry` property and the corresponding values are stored as one `Tensor` in `values`.\nThe boundary conditions and values outside the geometry are determined by `boundary`.\n\nExamples:\n    Create a periodic 2D grid, initialized via noise fluctuations.\n    >>> Field(UniformGrid(x=32, y=32), values=Noise(), boundary=PERIODIC)\n\n    Create a field on an unstructured mesh loaded from a .gmsh file\n    >>> mesh = phi.geom.load_gmsh('cylinder.msh', ('y-', 'x+', 'y+', 'x-', 'cyl+', 'cyl-'))\n    >>> Field(mesh, values=vec(x=1, y=0), boundary={'x': ZERO_GRADIENT, 'y': 0, 'cyl': 0})\n\n    Create two cubes and compute a scalar values for each.\n    >>> Field(Cuboid(vec(x=[0, 2], y=0), x=1, y=1), values=lambda x,y: x)\n\nSee the `phi.field` module documentation at https://tum-pbs.github.io/PhiFlow/Fields.html",
                    "signature": "(geometry: Union[phi.geom._geom.Geometry, phiml.math._tensors.Tensor], values: Union[phiml.math._tensors.Tensor, numbers.Number, bool, Callable, phi.field._field.FieldInitializer, phi.geom._geom.Geometry, ForwardRef('Field')], boundary: Union[numbers.Number, phiml.math.extrapolation.Extrapolation, ForwardRef('Field'), dict] = 0.0, variable_attrs=('values',), value_attrs=('values',), **sampling_kwargs)",
                    "type": "class",
                    "methods": [
                        {
                            "name": "as_boundary",
                            "qualname": "Field.as_boundary",
                            "docstring": "Returns an `Extrapolation` representing this 'Field''s values as a Dirichlet (constant) boundary.\nIf this `Field` encloses the required boundaries, its values will be interpolated to the required boundaries.\nIf boundaries outside of this `Field`'s sampled domain are required, this `Field`'s boundary conditions will be applied to determine the boundary values.\n\nReturns:\n    `Extrapolation`",
                            "signature": "(self) -> phiml.math.extrapolation.Extrapolation"
                        },
                        {
                            "name": "as_points",
                            "qualname": "Field.as_points",
                            "docstring": "Returns this field as a PointCloud.\nThis replaces the `Field.geometry` with a `phi.geom.Point` instance while leaving the sample points unchanged.\n\nSee Also:\n    `Field.as_spheres()`.\n\nArgs:\n    list_dim: If not `None`, packs spatial, instance and dual dims.\n        Defaults to `instance('elements')`.\n\nReturns:\n    `Field` with same values and boundaries but `Point` geometry.",
                            "signature": "(self, list_dim: Optional[phiml.math._shape.Shape] = (elements\u2071=None)) -> 'Field'"
                        },
                        {
                            "name": "as_spheres",
                            "qualname": "Field.as_spheres",
                            "docstring": "Returns this field as a PointCloud with spherical / circular elements, preserving element volumes.\nThis replaces the `Field.geometry` with a `phi.geom.Sphere` instance while leaving the sample points unchanged.\n\nSee Also:\n    `Field.as_points()`.\n\nArgs:\n    list_dim: If not `None`, packs spatial, instance and dual dims.\n        Defaults to `instance('elements')`.\n\nReturns:\n    `Field` with same values and boundaries but `Sphere` geometry.",
                            "signature": "(self, list_dim: Optional[phiml.math._shape.Shape] = (elements\u2071=None)) -> 'Field'"
                        },
                        {
                            "name": "at",
                            "qualname": "Field.at",
                            "docstring": "Short for `resample(self, representation)`\n\nSee Also\n    `resample()`.\n\nReturns:\n    Field object of same type as `representation`",
                            "signature": "(self, representation: Union[ForwardRef('Field'), phi.geom._geom.Geometry], keep_boundary=False, **kwargs) -> 'Field'"
                        },
                        {
                            "name": "at_centers",
                            "qualname": "Field.at_centers",
                            "docstring": "Interpolates the values to the cell centers.\n\nSee Also:\n    `Field.at_faces()`, `Field.at()`, `resample`.\n\nArgs:\n    **kwargs: Sampling arguments.\n\nReturns:\n    `CenteredGrid` sampled at cell centers.",
                            "signature": "(self, **kwargs) -> 'Field'"
                        },
                        {
                            "name": "at_faces",
                            "qualname": "Field.at_faces",
                            "docstring": "",
                            "signature": "(self, boundary=None, **kwargs) -> 'Field'"
                        },
                        {
                            "name": "closest_values",
                            "qualname": "Field.closest_values",
                            "docstring": "Sample the closest grid point values of this field at the world-space locations (in physical units) given by `points`.\nPoints must have a single channel dimension named `vector`.\nIt may additionally contain any number of batch and spatial dimensions, all treated as batch dimensions.\n\nArgs:\n    points: world-space locations\n\nReturns:\n    Closest grid point values as a `Tensor`.\n    For each dimension, the grid points immediately left and right of the sample points are evaluated.\n    For each point in `points`, a *2^d* cube of points is determined where *d* is the number of spatial dimensions of this field.\n    These values are stacked along the new dimensions `'closest_<dim>'` where `<dim>` refers to the name of a spatial dimension.",
                            "signature": "(self, points: phiml.math._tensors.Tensor)"
                        },
                        {
                            "name": "curl",
                            "qualname": "Field.curl",
                            "docstring": "Alias for `phi.field.curl`",
                            "signature": "(self, at='corner')"
                        },
                        {
                            "name": "dimension",
                            "qualname": "Field.dimension",
                            "docstring": "Returns a reference to one of the dimensions of this field.\n\nThe dimension reference can be used the same way as a `Tensor` dimension reference.\nNotable properties and methods of a dimension reference are:\nindexing using `[index]`, `unstack()`, `size`, `exists`, `is_batch`, `is_spatial`, `is_channel`.\n\nA shortcut to calling this function is the syntax `field.<dim_name>` which calls `field.dimension(<dim_name>)`.\n\nArgs:\n    name: dimension name\n\nReturns:\n    dimension reference",
                            "signature": "(self, name: str)"
                        },
                        {
                            "name": "divergence",
                            "qualname": "Field.divergence",
                            "docstring": "Alias for `phi.field.divergence`",
                            "signature": "(self, order=2, implicit: phiml.math._optimize.Solve = None, upwind: 'Field' = None)"
                        },
                        {
                            "name": "downsample",
                            "qualname": "Field.downsample",
                            "docstring": "",
                            "signature": "(self, factor: int)"
                        },
                        {
                            "name": "gradient",
                            "qualname": "Field.gradient",
                            "docstring": "Alias for `phi.field.spatial_gradient`",
                            "signature": "(self, boundary: phiml.math.extrapolation.Extrapolation = None, at: str = 'center', dims: Union[str, Sequence, set, phiml.math._shape.Shape, Callable, NoneType] = <function spatial at 0x000001F5FF553E20>, stack_dim: Union[phiml.math._shape.Shape, str] = (vector\u1d9c=None), order=2, implicit: phiml.math._optimize.Solve = None, scheme=None, upwind: 'Field' = None, gradient_extrapolation: phiml.math.extrapolation.Extrapolation = None)"
                        },
                        {
                            "name": "grid_scatter",
                            "qualname": "Field.grid_scatter",
                            "docstring": "Deprecated. Use `sample` with `scatter=True` instead.",
                            "signature": "(self, *args, **kwargs)"
                        },
                        {
                            "name": "laplace",
                            "qualname": "Field.laplace",
                            "docstring": "Alias for `phi.field.laplace`",
                            "signature": "(self, axes: Union[str, Sequence, set, phiml.math._shape.Shape, Callable, NoneType] = <function spatial at 0x000001F5FF553E20>, gradient: 'Field' = None, order=2, implicit: phiml.math._optimize.Solve = None, weights: Union[phiml.math._tensors.Tensor, ForwardRef('Field')] = None, upwind: 'Field' = None, correct_skew=True)"
                        },
                        {
                            "name": "numpy",
                            "qualname": "Field.numpy",
                            "docstring": "Return the field values as `NumPy` array(s).\n\nArgs:\n    order: Dimension order as `str` or `Shape`.\n\nReturns:\n    A single NumPy array for uniform values, else a list of NumPy arrays.",
                            "signature": "(self, order: Union[str, Sequence, set, phiml.math._shape.Shape, Callable, NoneType] = None)"
                        },
                        {
                            "name": "pad",
                            "qualname": "Field.pad",
                            "docstring": "Alias for `phi.field.pad()`.\n\nPads this `Field` using its extrapolation.\n\nUnlike padding the values, this function also affects the `geometry` of the field, changing its size and origin depending on `widths`.\n\nArgs:\n    widths: Either `int` or `(lower, upper)` to pad the same number of cells in all spatial dimensions\n        or `dict` mapping dimension names to `(lower, upper)`.\n\nReturns:\n    Padded `Field`",
                            "signature": "(self, widths: Union[int, tuple, list, dict]) -> 'Field'"
                        },
                        {
                            "name": "sample",
                            "qualname": "Field.sample",
                            "docstring": "Sample the values of this `Field` at the given location or geometry.\n\nArgs:\n    where: Location `Tensor` or `Geometry` or\n    at: `'center'` or `'face'`.\n    **kwargs: Sampling arguments.\n\nReturns:\n    `Tensor`",
                            "signature": "(self, where: Union[phi.geom._geom.Geometry, ForwardRef('Field'), phiml.math._tensors.Tensor], at: str = 'center', **kwargs) -> 'Tensor'"
                        },
                        {
                            "name": "shifted",
                            "qualname": "Field.shifted",
                            "docstring": "Move the positions of this field's `geometry` by `delta`.\n\nSee Also:\n    `Field.shifted_to`.\n\nArgs:\n    delta: Shift amount for each center position of `geometry`.\n\nReturns:\n    New `Field` sampled at `geometry.center + delta`.",
                            "signature": "(self, delta: phiml.math._tensors.Tensor) -> 'Field'"
                        },
                        {
                            "name": "shifted_to",
                            "qualname": "Field.shifted_to",
                            "docstring": "Move the positions of this field's `geometry` to `positions`.\n\nSee Also:\n    `Field.shifted`.\n\nArgs:\n    position: New center positions of `geometry`.\n\nReturns:\n    New `Field` sampled at given positions.",
                            "signature": "(self, position: phiml.math._tensors.Tensor) -> 'Field'"
                        },
                        {
                            "name": "staggered_tensor",
                            "qualname": "Field.staggered_tensor",
                            "docstring": "Stacks all component grids into a single uniform `phi.math.Tensor`.\nThe individual components are padded to a common (larger) shape before being stacked.\nThe shape of the returned tensor is exactly one cell larger than the grid `resolution` in every spatial dimension.\n\nReturns:\n    Uniform `phi.math.Tensor`.",
                            "signature": "(self) -> phiml.math._tensors.Tensor"
                        },
                        {
                            "name": "to_grid",
                            "qualname": "Field.to_grid",
                            "docstring": "",
                            "signature": "(self, resolution=(), bounds=None, **resolution_)"
                        },
                        {
                            "name": "uniform_values",
                            "qualname": "Field.uniform_values",
                            "docstring": "Returns a uniform tensor containing `values`.\n\nFor periodic grids, which always have a uniform value tensor, `values' is returned directly.\nIf `values` is not uniform, it is padded as in `StaggeredGrid.staggered_tensor()`.",
                            "signature": "(self)"
                        },
                        {
                            "name": "with_boundary",
                            "qualname": "Field.with_boundary",
                            "docstring": "Returns a copy of this field with the `boundary` replaced.",
                            "signature": "(self, boundary)"
                        },
                        {
                            "name": "with_bounds",
                            "qualname": "Field.with_bounds",
                            "docstring": "Returns a copy of this field with `bounds` replaced.",
                            "signature": "(self, bounds: phi.geom._box.Box)"
                        },
                        {
                            "name": "with_elements",
                            "qualname": "Field.with_geometry",
                            "docstring": "Returns a copy of this field with `elements` replaced.",
                            "signature": "(self, elements: phi.geom._geom.Geometry)"
                        },
                        {
                            "name": "with_extrapolation",
                            "qualname": "Field.with_boundary",
                            "docstring": "Returns a copy of this field with the `boundary` replaced.",
                            "signature": "(self, boundary)"
                        },
                        {
                            "name": "with_geometry",
                            "qualname": "Field.with_geometry",
                            "docstring": "Returns a copy of this field with `elements` replaced.",
                            "signature": "(self, elements: phi.geom._geom.Geometry)"
                        },
                        {
                            "name": "with_values",
                            "qualname": "Field.with_values",
                            "docstring": "Returns a copy of this field with `values` replaced.",
                            "signature": "(self, values, **sampling_kwargs)"
                        }
                    ]
                },
                {
                    "name": "HardGeometryMask",
                    "qualname": "HardGeometryMask",
                    "docstring": "Deprecated since version 2.3. Use `phi.field.mask()` or `phi.field.resample()` instead.",
                    "signature": "(geometry: phi.geom._geom.Geometry)",
                    "type": "class",
                    "methods": []
                },
                {
                    "name": "Noise",
                    "qualname": "Noise",
                    "docstring": "Generates random noise fluctuations which can be configured in physical size and smoothness.\nEach time values are sampled from a Noise field, a new noise field is generated.\n\nNoise is typically used as an initializer for CenteredGrids or StaggeredGrids.\n\nArgs:\n  shape: Batch and channel dimensions. Spatial dimensions will be added automatically once sampled on a grid.\n  scale: Size of noise fluctuations in physical units.\n  smoothness: Determines how quickly high frequencies die out.\n  **dims: Additional dimensions, added to `shape`.",
                    "signature": "(*shape: phiml.math._shape.Shape, scale=10.0, smoothness=1.0, **channel_dims)",
                    "type": "class",
                    "methods": [
                        {
                            "name": "grid_sample",
                            "qualname": "Noise.grid_sample",
                            "docstring": "",
                            "signature": "(self, resolution: phiml.math._shape.Shape, size, shape: phiml.math._shape.Shape = None)"
                        }
                    ]
                },
                {
                    "name": "Scene",
                    "qualname": "Scene",
                    "docstring": "Provides methods for reading and writing simulation data.\n\nSee the format documentation at https://tum-pbs.github.io/PhiFlow/Scene_Format_Specification.html .\n\nAll data of a `Scene` is located inside a single directory with name `sim_xxxxxx` where `xxxxxx` is the `id`.\nThe data of the scene is organized into NumPy files by *name* and *frame*.\n\nTo create a new scene, use `Scene.create()`.\nTo reference an existing scene, use `Scene.at()`.\nTo list all scenes within a directory, use `Scene.list()`.",
                    "signature": "(paths: Union[str, phiml.math._tensors.Tensor])",
                    "type": "class",
                    "methods": [
                        {
                            "name": "copy_calling_script",
                            "qualname": "Scene.copy_calling_script",
                            "docstring": "Copies the Python file that called this method into the `src` folder of this `Scene`.\n\nIn batch mode, the script is copied to all scenes.\n\nArgs:\n    full_trace: Whether to include scripts that indirectly called this method.\n    include_context_information: If True, writes the phiflow version and `sys.argv` into `context.json`.",
                            "signature": "(self, full_trace=False, include_context_information=True)"
                        },
                        {
                            "name": "copy_src",
                            "qualname": "Scene.copy_src",
                            "docstring": "",
                            "signature": "(self, script_path, only_external=True)"
                        },
                        {
                            "name": "copy_src_text",
                            "qualname": "Scene.copy_src_text",
                            "docstring": "",
                            "signature": "(self, filename, text)"
                        },
                        {
                            "name": "exist_properties",
                            "qualname": "Scene.exist_properties",
                            "docstring": "Checks whether the file `description.json` exists or has existed.",
                            "signature": "(self)"
                        },
                        {
                            "name": "exists_config",
                            "qualname": "Scene.exists_config",
                            "docstring": "Tests if the configuration file *description.json* exists. In batch mode, tests if any configuration exists.",
                            "signature": "(self)"
                        },
                        {
                            "name": "mkdir",
                            "qualname": "Scene.mkdir",
                            "docstring": "",
                            "signature": "(self)"
                        },
                        {
                            "name": "put_properties",
                            "qualname": "Scene.put_properties",
                            "docstring": "Updates the properties dictionary and stores it in `description.json` of all scene folders.\n\nArgs:\n    update: new values, must be JSON serializable.\n    kw_updates: additional update as keyword arguments. This overrides `update`.",
                            "signature": "(self, update: dict = None, **kw_updates)"
                        },
                        {
                            "name": "put_property",
                            "qualname": "Scene.put_property",
                            "docstring": "See `Scene.put_properties()`.",
                            "signature": "(self, key, value)"
                        },
                        {
                            "name": "read",
                            "qualname": "Scene.read",
                            "docstring": "Reads one or multiple fields from disc.\n\nSee Also:\n    `Scene.write()`.\n\nArgs:\n    names: Single field name or sequence of field names.\n    frame: Frame number.\n    convert_to_backend: Whether to convert the read data to the data format of the default backend, e.g. TensorFlow tensors.\n\nReturns:\n    Single `phi.field.Field` or sequence of fields, depending on the type of `names`.",
                            "signature": "(self, *names: str, frame=0, convert_to_backend=True)"
                        },
                        {
                            "name": "read_array",
                            "qualname": "Scene.read_field",
                            "docstring": "Reads a single `Field` from files contained in this `Scene` (batch).\n\nArgs:\n    name: Base file name.\n    frame: Frame number as `int`, typically time step index.\n    convert_to_backend: Whether to convert the read data to the data format of the default backend, e.g. TensorFlow tensors.\n\nReturns:\n    `Field`",
                            "signature": "(self, name: str, frame: int, convert_to_backend=True) -> phi.field._field.Field"
                        },
                        {
                            "name": "read_field",
                            "qualname": "Scene.read_field",
                            "docstring": "Reads a single `Field` from files contained in this `Scene` (batch).\n\nArgs:\n    name: Base file name.\n    frame: Frame number as `int`, typically time step index.\n    convert_to_backend: Whether to convert the read data to the data format of the default backend, e.g. TensorFlow tensors.\n\nReturns:\n    `Field`",
                            "signature": "(self, name: str, frame: int, convert_to_backend=True) -> phi.field._field.Field"
                        },
                        {
                            "name": "remove",
                            "qualname": "Scene.remove",
                            "docstring": "Deletes the scene directory and all contained files.",
                            "signature": "(self)"
                        },
                        {
                            "name": "rename",
                            "qualname": "Scene.rename",
                            "docstring": "Deletes the scene directory and all contained files.",
                            "signature": "(self, name: str)"
                        },
                        {
                            "name": "subpath",
                            "qualname": "Scene.subpath",
                            "docstring": "Resolves the relative path `name` with this `Scene` as the root folder.\n\nArgs:\n    name: Relative path with this `Scene` as the root folder.\n    create: Whether to create a directory of that name.\n    create_parent: Whether to create the parent directory.\n\nReturns:\n    Relative path including the path to this `Scene`.\n    In batch mode, returns a `tuple`, else a `str`.",
                            "signature": "(self, name: str, create=False, create_parent=False) -> Union[str, tuple]"
                        },
                        {
                            "name": "write",
                            "qualname": "Scene.write",
                            "docstring": "Writes fields to this scene.\nOne NumPy file will be created for each `phi.field.Field`\n\nSee Also:\n    `Scene.read()`.\n\nArgs:\n    data: `dict` mapping field names to `Field` objects that can be written using `phi.field.write()`.\n    kw_data: Additional data, overrides elements in `data`.\n    frame: Frame number.",
                            "signature": "(self, data: dict = None, frame=0, **kw_data)"
                        },
                        {
                            "name": "write_field",
                            "qualname": "Scene.write_field",
                            "docstring": "Write a `Field` to a file.\nThe filenames are created from the provided names and the frame index in accordance with the\nscene format specification at https://tum-pbs.github.io/PhiFlow/Scene_Format_Specification.html .\n\nArgs:\n    field: single field or structure of Fields to save.\n    name: Base file name.\n    frame: Frame number as `int`, typically time step index.",
                            "signature": "(self, field: phi.field._field.Field, name: str, frame: int)"
                        }
                    ]
                },
                {
                    "name": "GeometryMask",
                    "qualname": "SoftGeometryMask",
                    "docstring": "Deprecated since version 2.3. Use `phi.field.mask()` or `phi.field.resample()` instead.",
                    "signature": "(geometry: phi.geom._geom.Geometry, balance: Union[phiml.math._tensors.Tensor, float] = 0.5)",
                    "type": "class",
                    "methods": []
                },
                {
                    "name": "SoftGeometryMask",
                    "qualname": "SoftGeometryMask",
                    "docstring": "Deprecated since version 2.3. Use `phi.field.mask()` or `phi.field.resample()` instead.",
                    "signature": "(geometry: phi.geom._geom.Geometry, balance: Union[phiml.math._tensors.Tensor, float] = 0.5)",
                    "type": "class",
                    "methods": []
                }
            ],
            "submodules": []
        },
        {
            "type": "module",
            "name": "flow",
            "docstring": "*Main PhiFlow import:* `from phi.flow import *`\n\nImports important functions and classes from\n`math`, `geom`, `field`, `physics` and `vis` (including sub-modules)\nas well as the modules and sub-modules themselves.\n\nSee `phi.tf.flow`, `phi.torch.flow`, `phi.jax.flow`.",
            "functions": [],
            "classes": [],
            "submodules": []
        },
        {
            "type": "module",
            "name": "geom",
            "docstring": "Differentiable geometry package.\n\nClasses:\n\n* `Geometry` (base type)\n* `Box`\n* `Sphere`\n\nSee the `phi.geom` module documentation at https://tum-pbs.github.io/PhiFlow/Geometry.html",
            "functions": [
                {
                    "name": "Cuboid",
                    "qualname": "Cuboid",
                    "docstring": "Args:\n    center: Center position\n    half_size: Half-size of the cuboid as vector or scalar\n    rotation: Rotation angle(s) or rotation matrix.\n    is_open: Specify which faces are open, i.e. have infinite extent.\n    variable_attrs: Which properties of the box are treated as variable.\n    **size: Alternative way of specifying the size. If used, `half_size` must not be specified.",
                    "signature": "(center: phiml.math._tensors.Tensor = 0, half_size: Union[float, phiml.math._tensors.Tensor] = None, rotation: Optional[phiml.math._tensors.Tensor] = None, is_open: phiml.math._tensors.Tensor = False, variable_attrs=('pos', 'size', 'rot'), **size: Union[float, phiml.math._tensors.Tensor]) -> phi.geom._box.Box"
                },
                {
                    "name": "as_sdf",
                    "qualname": "as_sdf",
                    "docstring": "Represent existing geometry as a signed distance function.\n\nArgs:\n    geo: `Geometry` to represent as a signed distance function.\n        Must implement `Geometry.approximate_signed_distance()`.\n    bounds: Bounds of the SDF. If `None` will be determined from bounds of `geo` and `rel_margin`/`abs_margin`.\n    rel_margin: Relative size to pad the domain on all sides around the bounds of `geo`.\n        For example, 0.1 will pad 10% of `geo`'s size in each axis on both sides.\n    abs_margin: World-space size to pad the domain on all sides around the bounds of `geo`.\n    separate: Dimensions along which to unstack `geo` and return individual SDFs.\n        Once created, SDFs cannot be unstacked.\n\nReturns:\n    `SDF` representation of `geo`.",
                    "signature": "(geo: phi.geom._geom.Geometry, bounds=None, rel_margin=None, abs_margin=0.0, separate: Union[str, Sequence, set, phiml.math._shape.Shape, Callable, NoneType] = None, method='auto') -> phi.geom._sdf.SDF"
                },
                {
                    "name": "assert_same_rank",
                    "qualname": "assert_same_rank",
                    "docstring": "Tests that two objects have the same spatial rank. Objects can be of types: `int`, `None` (no check), `Geometry`, `Shape`, `Tensor`",
                    "signature": "(rank1, rank2, error_message)"
                },
                {
                    "name": "bounding_box",
                    "qualname": "bounding_box",
                    "docstring": "Builds a bounding box around `geometry` or a collection of points.\n\nArgs:\n    geometry: `Geometry` object or `Tensor` of points.\n    reduce: Which objects to includes in each bounding box. Non-reduced dims will be part of the returned box.\n\nReturns:\n    Bounding `Box` containing only batch dims and `vector`.",
                    "signature": "(geometry: Union[phi.geom._geom.Geometry, phiml.math._tensors.Tensor], reduce=<function non_batch at 0x0000024EC5B940E0>) -> phi.geom._box.Box"
                },
                {
                    "name": "build_mesh",
                    "qualname": "build_mesh",
                    "docstring": "Build a mesh for a given domain, respecting obstacles.\n\nArgs:\n    bounds: Bounds for uniform cells.\n    resolution: Base resolution\n    obstacles: Single `Geometry` or `dict` mapping boundary name to corresponding `Geometry`.\n    method: Meshing algorithm. Only `quad` is currently supported.\n    cell_dim: Dimension along which to list the cells. This should be an instance dimension.\n    face_format: Sparse storage format for cell connectivity.\n    max_squish: Smallest allowed cell size compared to the smallest regular cell.\n    **resolution_: For uniform grid, pass resolution as `int` and specify `bounds`.\n        Or pass a sequence of floats for each dimension, specifying the vertex positions along each axis.\n        This allows for variable cell stretching.\n\nReturns:\n    `Mesh`",
                    "signature": "(bounds: phi.geom._box.Box = None, resolution=(), obstacles: Union[phi.geom._geom.Geometry, Dict[str, phi.geom._geom.Geometry]] = None, method='quad', cell_dim: phiml.math._shape.Shape = (cells\u2071=None), face_format: str = 'csc', max_squish: Optional[float] = 0.5, **resolution_: Union[int, phiml.math._tensors.Tensor, tuple, list, Any]) -> phi.geom._mesh.Mesh"
                },
                {
                    "name": "clip_length",
                    "qualname": "clip_length",
                    "docstring": "Clips the length of a vector to the interval `[min_len, max_len]` while keeping the direction.\nZero-vectors remain zero-vectors.\n\nArgs:\n    vec: `Tensor`\n    min_len: Lower clipping threshold.\n    max_len: Upper clipping threshold.\n    vec_dim: Dimensions to compute the length over. By default, all channel dimensions are used to compute the vector length.\n    eps: Minimum vector length. Use to avoid `inf` gradients for zero-length vectors.\n\nReturns:\n    `Tensor` with same shape as `vec`.",
                    "signature": "(vec: phiml.math._tensors.Tensor, min_len=0, max_len=1, vec_dim: Union[str, Sequence, set, phiml.math._shape.Shape, Callable, NoneType] = 'vector', eps: Union[float, phiml.math._tensors.Tensor] = 1e-05)"
                },
                {
                    "name": "concat",
                    "qualname": "concat",
                    "docstring": "Concatenates a sequence of `phiml.math.magic.Shapable` objects, e.g. `Tensor`, along one dimension.\nAll values must have the same spatial, instance and channel dims and their sizes must be equal, except for `dim`.\nBatch dims will be added as needed.\n\nArgs:\n    values: Tuple or list of `phiml.math.magic.Shapable`, such as `phiml.math.Tensor`\n    dim: Concatenation dimension, must be present in all `values`.\n        The size along `dim` is determined from `values` and can be set to undefined (`None`).\n        Alternatively, a `str` of the form `'t->name:t'` can be specified, where `t` is on of `b d i s c` denoting the dimension type.\n        This first packs all dims of the input into a new dim with given name and type, then concatenates the values along this dim.\n    expand_values: If `True`, will first add missing dims to all values, not just batch dimensions.\n        This allows tensors with different dims to be concatenated.\n        The resulting tensor will have all dims that are present in `values`.\n    **kwargs: Additional keyword arguments required by specific implementations.\n        Adding spatial dims to fields requires the `bounds: Box` argument specifying the physical extent of the new dimensions.\n        Adding batch dims must always work without keyword arguments.\n\nReturns:\n    Concatenated `Tensor`\n\nExamples:\n    >>> concat([math.zeros(batch(b=10)), math.ones(batch(b=10))], 'b')\n    (b\u1d47=20) 0.500 \u00b1 0.500 (0e+00...1e+00)\n\n    >>> concat([vec(x=1, y=0), vec(z=2.)], 'vector')\n    (x=1.000, y=0.000, z=2.000) float64",
                    "signature": "(values: Sequence[~PhiTreeNodeType], dim: Union[str, phiml.math._shape.Shape], expand_values=False, **kwargs) -> ~PhiTreeNodeType"
                },
                {
                    "name": "cross",
                    "qualname": "cross",
                    "docstring": "Computes the cross product of two vectors in 2D.\n\nArgs:\n    vec1: `Tensor` with a single channel dimension called `'vector'`\n    vec2: `Tensor` with a single channel dimension called `'vector'`\n\nReturns:\n    `Tensor`",
                    "signature": "(vec1: phiml.math._tensors.Tensor, vec2: phiml.math._tensors.Tensor) -> phiml.math._tensors.Tensor"
                },
                {
                    "name": "cylinder",
                    "qualname": "cylinder",
                    "docstring": "Args:\n    center: Cylinder center as `Tensor` with `vector` dimension.\n        The spatial dimension order should be specified in the `vector` dimension via item names.\n        Can be left empty to specify dimensions via kwargs.\n    radius: Cylinder radius as `float` or `Tensor`.\n    depth: Cylinder length as `float` or `Tensor`.\n    rotation: Rotation angle(s) or rotation matrix.\n    axis: The cylinder is aligned along this axis, perturbed by `rotation`.\n        Specified either as the dim along which the cylinder is aligned or as a vector.\n    variables: Which properties of the cylinder are variable, i.e. traced and optimizable. All by default.\n    **center_: Specifies center when the `center` argument is not given. Center position by dimension, e.g. `x=0.5, y=0.2`.",
                    "signature": "(center: Union[phiml.math._tensors.Tensor, float] = None, radius: Union[float, phiml.math._tensors.Tensor] = None, depth: Union[float, phiml.math._tensors.Tensor] = None, rotation: Optional[phiml.math._tensors.Tensor] = None, axis: Union[int, str, phiml.math._tensors.Tensor] = -1, variables=('center', 'radius', 'depth', 'rotation'), **center_: Union[float, phiml.math._tensors.Tensor]) -> phi.geom._cylinder.Cylinder"
                },
                {
                    "name": "embed",
                    "qualname": "embed",
                    "docstring": "Adds fake spatial dimensions to a geometry.\nThe geometry value will be constant along the added dimensions, as if it had infinite length in these directions.\n\nDimensions that are already present with `geometry` are ignored.\n\nArgs:\n    geometry: `Geometry`\n    projected_dims: Additional dimensions\n\nReturns:\n    `Geometry` with spatial rank `geometry.spatial_rank + projected_dims.rank`.",
                    "signature": "(geometry: phi.geom._geom.Geometry, projected_dims: Union[phiml.math._shape.Shape, str, tuple, list, NoneType]) -> phi.geom._geom.Geometry"
                },
                {
                    "name": "enclosing_grid",
                    "qualname": "enclosing_grid",
                    "docstring": "Constructs a `UniformGrid` which fully encloses the `geometries`.\nThe grid voxels are chosen to have approximately the same size along each axis.\n\nArgs:\n    *geometries: `Geometry` objects `Tensor` of points which should lie within the grid.\n    voxel_count: Approximate number of total voxels.\n    rel_margin: Relative margin, i.e. empty space on each side as a fraction of the bounding box size of `geometries`.\n    abs_margin: Absolute margin, i.e. empty space on each side.\n    margin_cells: Number of cell layers to fit outside the bounding box around `geometries`. This is cumulative with `rel_margin` and `abs_margin`.\n\nReturns:\n    `UniformGrid`",
                    "signature": "(*geometries: Union[phi.geom._geom.Geometry, phiml.math._tensors.Tensor], voxel_count: int, rel_margin=0.0, abs_margin=0.0, margin_cells=0) -> phi.geom._grid.UniformGrid"
                },
                {
                    "name": "farthest_points",
                    "qualname": "farthest_points",
                    "docstring": "Perform farthest point sampling (FPS) on a set of 3D points.\n\nParameters:\n    points (numpy.ndarray): (N, 3) array of 3D points.\n    list_dim: Number of points to sample and dimension along which to list the sampled points.\n    must_contain: (Optional) Indices of points that must be contained in the sample. Duplicate indices will only be sampled once.\n\nReturns:\n    numpy.ndarray: (M, 3) array of sampled points.",
                    "signature": "(points: phiml.math._tensors.Tensor, list_dim: phiml.math._shape.Shape, must_contain: phiml.math._tensors.Tensor = None)"
                },
                {
                    "name": "graph",
                    "qualname": "graph",
                    "docstring": "Construct a `Graph`.\n\nArgs:\n    nodes: Location `Tensor` or `Geometry` objects representing the nodes.\n    edges: Connectivity and edge value `Tensor`.\n    boundary: Named boundary sets.\n\nReturns:\n    `Graph`",
                    "signature": "(nodes: Union[phi.geom._geom.Geometry, phiml.math._tensors.Tensor], edges: phiml.math._tensors.Tensor, boundary: Dict[str, Dict[str, slice]] = None, build_distances=True, build_bounding_distance=False) -> phi.geom._graph.Graph"
                },
                {
                    "name": "infinite_cylinder",
                    "qualname": "infinite_cylinder",
                    "docstring": "Creates an infinite cylinder.\nThis is equal to embedding an `n`-dimensional `Sphere` in `n+1` dimensions.\n\nSee Also:\n    `Sphere`, `embed`\n\nArgs:\n    center: Center coordinates without `inf_dim`. Alternatively use keyword arguments.\n    radius: Cylinder radius.\n    inf_dim: Dimension along which the cylinder is infinite.\n        Use `Geometry.rotated()` if the direction does not align with an axis.\n    **center_: Alternatively specify center coordinates without `inf_dim` as keyword arguments.\n\nReturns:\n    `Geometry`",
                    "signature": "(center=None, radius=None, inf_dim: Union[str, phiml.math._shape.Shape, tuple, list] = None, **center_) -> phi.geom._geom.Geometry"
                },
                {
                    "name": "intersection",
                    "qualname": "intersection",
                    "docstring": "Intersection of the given geometries.\nA point lies inside the union if it lies within all of the geometries.\n\nArgs:\n    *geometries: arbitrary geometries with same spatial dims. Arbitrary batch dims are allowed.\n    dim: Intersection dimension. This must be an instance dimension.\n\nReturns:\n    intersection `Geometry`",
                    "signature": "(*geometries: phi.geom._geom.Geometry, dim=(intersection\u2071=None)) -> phi.geom._geom.Geometry"
                },
                {
                    "name": "invert",
                    "qualname": "invert",
                    "docstring": "Swaps inside and outside.\n\nArgs:\n    geometry: `phi.geom.Geometry` to swap\n\nReturns:\n    New `phi.geom.Geometry` object with same surface but swapped normals",
                    "signature": "(geometry: phi.geom._geom.Geometry)"
                },
                {
                    "name": "join_meshes",
                    "qualname": "join_meshes",
                    "docstring": "Creates a mesh that contains the vertices and elements of all `meshes`.\nVertex and elements are concatenated, thereby increasing the indices as needed.\n\nArgs:\n    meshes: Collection of `Mesh` instances.\n\nReturns:\n    `Mesh`",
                    "signature": "(meshes: Sequence[phi.geom._mesh.Mesh]) -> phi.geom._mesh.Mesh"
                },
                {
                    "name": "length",
                    "qualname": "length",
                    "docstring": "Returns the length of a vector `Tensor` or geometric object with a length-like property.\n\nArgs:\n    obj: `Tensor` with 'vector' dim or `Geometry` with a length-like property.\n    epsilon: Minimum valid vector length. Use to avoid `inf` gradients for zero-length vectors.\n        Lengths shorter than `eps` are set to 0.\n\nReturns:\n    Length as `Tensor`",
                    "signature": "(obj: Union[phi.geom._geom.Geometry, phiml.math._tensors.Tensor], epsilon=None) -> phiml.math._tensors.Tensor"
                },
                {
                    "name": "line_trace",
                    "qualname": "line_trace",
                    "docstring": "Trace a line until it hits the surface of `geo`.\nThe surface can be hit either from the outside or the inside.\n\nArgs:\n    geo: `Geometry` that implements `approximate_closest_surface`.\n    origin: Line start location.\n    direction: Unit vector pointing in the line direction.\n    side: 'outside' or 'inside' or 'both'.\n    tolerance: Surface distance tolerance.\n    max_iter: Maximum number of steps per line.\n    step_size: Step size factor. This can be set to `1` if the signed distance values of `geo` are exact.\n        For inexact SDFs, smaller step sizes prevent skipping over surfaces.\n\nReturns:\n    hit: Whether a surface intersection was found for the line.\n    distance: Distance between the line and the surface.\n    position: Hit location or point until which the line was traced.\n    normal: Surface normal at hit location\n    hit_index: Geometry face index at hit location",
                    "signature": "(geo: phi.geom._geom.Geometry, origin: phiml.math._tensors.Tensor, direction: phiml.math._tensors.Tensor, side='both', tolerance=None, max_iter=64, step_size=0.9, max_line_length=None) -> Tuple[phiml.math._tensors.Tensor, phiml.math._tensors.Tensor, phiml.math._tensors.Tensor, phiml.math._tensors.Tensor, Optional[phiml.math._tensors.Tensor]]"
                },
                {
                    "name": "load_gmsh",
                    "qualname": "load_gmsh",
                    "docstring": "Load an unstructured mesh from a `.msh` file.\n\nThis requires the package `meshio` to be installed.\n\nArgs:\n    file: Path to `.su2` file.\n    boundary_names: Boundary identifiers corresponding to the blocks in the file. If not specified, boundaries will be numbered.\n    periodic:\n    cell_dim: Dimension along which to list the cells. This should be an instance dimension.\n    face_format: Sparse storage format for cell connectivity.\n\nReturns:\n    `Mesh`",
                    "signature": "(file: str, boundary_names: Sequence[str] = None, periodic: str = None, cell_dim=(cells\u2071=None), face_format: str = 'csc')"
                },
                {
                    "name": "load_stl",
                    "qualname": "load_stl",
                    "docstring": "Load a triangle `Mesh` from an STL file.\n\nArgs:\n    file: File path to `.stl` file.\n    face_dim: Instance dim along which to list the triangles.\n\nReturns:\n    `Mesh` with `spatial_rank=3` and `element_rank=2`.",
                    "signature": "(file: str, face_dim=(faces\u2071=None)) -> phi.geom._mesh.Mesh"
                },
                {
                    "name": "load_su2",
                    "qualname": "load_su2",
                    "docstring": "Load an unstructured mesh from a `.su2` file.\n\nThis requires the package `ezmesh` to be installed.\n\nArgs:\n    file_or_mesh: Path to `.su2` file or *ezmesh* `Mesh` instance.\n    cell_dim: Dimension along which to list the cells. This should be an instance dimension.\n    face_format: Sparse storage format for cell connectivity.\n\nReturns:\n    `Mesh`",
                    "signature": "(file_or_mesh: str, cell_dim=(cells\u2071=None), face_format: str = 'csc') -> phi.geom._mesh.Mesh"
                },
                {
                    "name": "mesh",
                    "qualname": "mesh",
                    "docstring": "Create a mesh from vertex positions and vertex lists.\n\nArgs:\n    vertices: `Tensor` with one instance and one channel dimension `vector`.\n    elements: Lists of vertex indices as 2D tensor.\n        The elements must be listed along an instance dimension, and the vertex indices belonging to the same polygon must be listed along a spatial dimension.\n    boundaries: Pass a `str` to assign one name to all boundary faces.\n        For multiple boundaries, pass a `dict` mapping group names `str` to lists of faces, defined by their vertices.\n        The last entry can be `None` to group all boundary faces not explicitly listed before.\n        The `boundaries` `dict` maps boundary names to a list of edges (point pairs) in 2D and faces (3 or more points) in 3D (not yet supported).\n    face_format: Storage format for cell connectivity, must be one of `csc`, `coo`, `csr`, `dense`.\n\nReturns:\n    `Mesh`",
                    "signature": "(vertices: Union[phi.geom._geom.Geometry, phiml.math._tensors.Tensor], elements: phiml.math._tensors.Tensor, boundaries: Union[str, Dict[str, List[Sequence]], NoneType] = None, element_rank: int = None, periodic: str = None, face_format: str = 'csc', max_cell_walk: int = None)"
                },
                {
                    "name": "mesh_from_numpy",
                    "qualname": "mesh_from_numpy",
                    "docstring": "Construct an unstructured mesh from vertices.\n\nArgs:\n    points: 2D numpy array of shape (num_points, point_coord).\n        The last dimension must have length 2 for 2D meshes and 3 for 3D meshes.\n    polygons: List of elements. Each polygon is defined as a sequence of point indices mapping into `points'.\n        E.g. `[(0, 1, 2)]` denotes a single triangle connecting points 0, 1, and 2.\n    boundaries: An unstructured mesh can have multiple boundaries, each defined by a name `str` and a list of faces, defined by their vertices.\n        The `boundaries` `dict` maps boundary names to a list of edges (point pairs) in 2D and faces (3 or more points) in 3D (not yet supported).\n    cell_dim: Dimension along which to list the cells. This should be an instance dimension.\n    face_format: Storage format for cell connectivity, must be one of `csc`, `coo`, `csr`, `dense`.\n\nReturns:\n    `Mesh`",
                    "signature": "(points: Sequence[Sequence], polygons: Sequence[Sequence], boundaries: Union[str, Dict[str, List[Sequence]], NoneType] = None, element_rank: int = None, periodic: str = None, cell_dim: phiml.math._shape.Shape = (cells\u2071=None), face_format: str = 'csc', axes=('x', 'y', 'z')) -> phi.geom._mesh.Mesh"
                },
                {
                    "name": "normal_from_slope",
                    "qualname": "normal_from_slope",
                    "docstring": "Computes the normal vector of a line, plane, or hyperplane.\n\nArgs:\n    slope: Line Slope (2D), plane slope (3D) or hyperplane slope (4+D).\n        Must have one channel dimension listing the vector components.\n        The vector must list all but one dimensions of `space`.\n    space: Ordered spatial dimensions as comma-separated string, sequence of names or `Shape`\n\nReturns:\n    Normal vector with the channel dimension of `slope` listing all dimensions of `space` in that order.",
                    "signature": "(slope: phiml.math._tensors.Tensor, space: Union[str, phiml.math._shape.Shape, Sequence[str]])"
                },
                {
                    "name": "normalize",
                    "qualname": "normalize",
                    "docstring": "Normalize a vector `Tensor` along the 'vector' dim.\n\nArgs:\n    obj: `Tensor` with 'vector' dim.\n    epsilon: (Optional) Zero-length threshold. Vectors shorter than this length yield the unit vector (1, 0, 0, ...).\n        If not specified, the zero-vector yields `NaN` as it cannot be normalized.\n    allow_infinite: Allow infinite components in vectors. These vectors will then only points towards the infinite components.\n    allow_zero: Whether to return zero vectors for inputs smaller `epsilon` instead of a unit vector.\n\nReturns:\n    `Tensor` of the same shape as `obj`.",
                    "signature": "(obj: phiml.math._tensors.Tensor, epsilon=1e-05, allow_infinite=False, allow_zero=True)"
                },
                {
                    "name": "numpy_sdf",
                    "qualname": "numpy_sdf",
                    "docstring": "Define a `SDF` (signed distance function) from a NumPy function.\n\nArgs:\n    sdf: Function mapping a location `numpy.ndarray` of shape `(points, vector)` to the corresponding SDF value `(points,)`.\n    bounds: Bounds inside which the function is defined.\n    center: Optional center position of the object encoded via `sdf`.\n\nReturns:\n    `SDF`",
                    "signature": "(sdf: Callable, bounds: phi.geom._box.Box, center: phiml.math._tensors.Tensor = None) -> phi.geom._sdf.SDF"
                },
                {
                    "name": "pack_dims",
                    "qualname": "pack_dims",
                    "docstring": "Compresses multiple dims into a single dimension by concatenating the elements.\nElements along the new dims are laid out according to the order of `dims`.\nIf the order of `dims` differs from the current dimension order, the tensor is transposed accordingly.\nThis function replaces the traditional `reshape` for these cases.\n\nThe type of the new dimension will be equal to the types of `dims`.\nIf `dims` have varying types, the new dimension will be a batch dimension.\n\nIf none of `dims` exist on `value`, `packed_dim` will be added only if it is given with a definite size and `value` is not a primitive type.\n\nSee Also:\n    `unpack_dim()`\n\nArgs:\n    value: `phiml.math.magic.Shapable`, such as `phiml.math.Tensor`.\n    dims: Dimensions to be compressed in the specified order.\n    packed_dim: Single-dimension `Shape`.\n    pos: Index of new dimension. `None` for automatic, `-1` for last, `0` for first.\n    **kwargs: Additional keyword arguments required by specific implementations.\n        Adding spatial dims to fields requires the `bounds: Box` argument specifying the physical extent of the new dimensions.\n        Adding batch dims must always work without keyword arguments.\n\nReturns:\n    Same type as `value`.\n\nExamples:\n    >>> pack_dims(math.zeros(spatial(x=4, y=3)), spatial, instance('points'))\n    (points\u2071=12) const 0.0",
                    "signature": "(value, dims: Union[str, Sequence, set, phiml.math._shape.Shape, Callable, NoneType], packed_dim: Union[phiml.math._shape.Shape, str], pos: Optional[int] = None, **kwargs)"
                },
                {
                    "name": "rotate",
                    "qualname": "rotate",
                    "docstring": "Rotate a vector or `Geometry` about the `pivot`.\n\nArgs:\n    obj: n-dimensional vector `Tensor` or `Geometry`.\n    rot: Euler angle(s) or rotation matrix.\n        `None` is interpreted as no rotation.\n    invert: Whether to apply the inverse rotation.\n    pivot: Either a point (`Tensor`) lying on the rotation axis or one of the following strings: 'bounds', 'individual'.\n        Vector tensors are rotated about the origin if `pivot` is not given as a `Tensor`.\n\nReturns:\n    Rotated vector as `Tensor`",
                    "signature": "(obj: ~GeometricType, rot: Union[float, phiml.math._tensors.Tensor, NoneType], invert=False, pivot: Union[phiml.math._tensors.Tensor, str] = 'bounds') -> ~GeometricType"
                },
                {
                    "name": "rotation_angles",
                    "qualname": "rotation_angles",
                    "docstring": "Compute the scalar x in 2D or the Euler angles in 3D from a given rotation matrix.\nThis function returns one valid solution but often, there are multiple solutions.\n\nArgs:\n    rot: Rotation matrix as created by `phi.math.rotation_matrix()`.\n        Must have exactly one channel and one dual dimension with equally-ordered elements.\n\nReturns:\n    Scalar x in 2D, Euler angles",
                    "signature": "(rot: phiml.math._tensors.Tensor)"
                },
                {
                    "name": "rotation_matrix",
                    "qualname": "rotation_matrix",
                    "docstring": "Create a 2D or 3D rotation matrix from the corresponding angle(s).\n\nArgs:\n    x:\n        2D: scalar angle\n        3D: Either vector pointing along the rotation axis with rotation angle as length or Euler angles.\n        Euler angles need to be laid out along a `angle` channel dimension with dimension names listing the spatial dimensions.\n        E.g. a 90\u00b0 rotation about the z-axis is represented by `vec('angles', x=0, y=0, z=PI/2)`.\n        If a rotation matrix is passed for `angle`, it is returned without modification.\n    matrix_dim: Matrix dimension for 2D rotations. In 3D, the channel dimension of angle is used.\n\nReturns:\n    Matrix containing `matrix_dim` in primal and dual form as well as all non-channel dimensions of `x`.",
                    "signature": "(x: Union[float, phiml.math._tensors.Tensor, NoneType], matrix_dim=(vector\u1d9c=None), none_to_unit=False) -> Optional[phiml.math._tensors.Tensor]"
                },
                {
                    "name": "rotation_matrix_from_axis_and_angle",
                    "qualname": "rotation_matrix_from_axis_and_angle",
                    "docstring": "Computes a rotation matrix that rotates by `angle` around `axis`.\n\nArgs:\n    axis: 3D vector. `Tensor` with channel dim called 'vector'.\n    angle: Rotation angle.\n    is_axis_normalized: Whether `axis` has length 1.\n    epsilon: Minimum axis length. For shorter axes, the unit matrix is returned.\n\nReturns:\n    Rotation matrix as `Tensor` with 'vector' dim and its dual counterpart.",
                    "signature": "(axis: phiml.math._tensors.Tensor, angle: Union[float, phiml.math._tensors.Tensor], vec_dim='vector', is_axis_normalized=False, epsilon=1e-05) -> phiml.math._tensors.Tensor"
                },
                {
                    "name": "rotation_matrix_from_directions",
                    "qualname": "rotation_matrix_from_directions",
                    "docstring": "Computes a rotation matrix A, such that `target_dir = A @ source_dir`\n\nArgs:\n    source_dir: Two or three-dimensional vector. `Tensor` with channel dim called 'vector'.\n    target_dir: Two or three-dimensional vector. `Tensor` with channel dim called 'vector'.\n\nReturns:\n    Rotation matrix as `Tensor` with 'vector' dim and its dual counterpart.",
                    "signature": "(source_dir: phiml.math._tensors.Tensor, target_dir: phiml.math._tensors.Tensor, vec_dim: str = 'vector', epsilon=None) -> phiml.math._tensors.Tensor"
                },
                {
                    "name": "sample_function",
                    "qualname": "sample_function",
                    "docstring": "Calls `f`, passing either the `elements` directly or the relevant sample points as a `Tensor`, depending on the signature of `f`.\n\nArgs:\n    f: Function taking a `Geometry` or location `Tensor\u00b4 and returning a `Tensor`.\n        A `Geometry` will be passed if the first argument of `f` is called `geometry` or `geo` or ends with `_geo`.\n    elements: `Geometry` on which to sample `f`.\n    at: Set of sample points, see `Geometry.sets`.\n    extrapolation: Determines which boundary points are relevant.\n\nReturns:\n    Sampled values as `Tensor`.",
                    "signature": "(f: Callable, elements: phi.geom._geom.Geometry, at: str, extrapolation: phiml.math.extrapolation.Extrapolation) -> phiml.math._tensors.Tensor"
                },
                {
                    "name": "sample_sdf",
                    "qualname": "sample_sdf",
                    "docstring": "Build a grid of signed distance values for a given `Geometry` object.\n\nArgs:\n    geometry: `Geometry` to capture.\n    bounds: Grid limits in world space.\n    resolution: Grid resolution.\n    **resolution_: Grid resolution as `kwargs`, e.g. `x=64, y=32`.\n    approximate_outside: Whether queries outside the SDF grid should return approximate values. This requires additional computations.\n    rebuild: If `'from-surface'`, SDF values are calculated from a narrow strip above the enclosed surface. This is more accurate but requires additional steps.\n        If `None` (default), SDF values are queried from `geometry`.\n        `'auto'` rebuilds when geometry querying is expected to be in accurate.\n\nReturns:\n    SDF grid as `Geometry`.",
                    "signature": "(geometry: phi.geom._geom.Geometry, bounds: Union[phi.geom._box.Box, phi.geom._grid.UniformGrid] = None, resolution: phiml.math._shape.Shape = (), approximate_outside=False, rebuild: Optional[str] = None, valid_dist=None, rel_margin=0.1, abs_margin=0.0, cache_surface=False, **resolution_: int) -> phi.geom._sdf_grid.SDFGrid"
                },
                {
                    "name": "scale",
                    "qualname": "scale",
                    "docstring": "Scale a `Geometry` or vector `Tensor` about a pivot point.\n\nArgs:\n    obj: `Geometry` to scale.\n    scale: Scaling factor.\n    pivot: Point that stays fixed under the scaling operation. Defaults to the bounding box center.\n\nReturns:\n    Rotated `Geometry`",
                    "signature": "(obj: ~GeometricType, scale: Union[float, phiml.math._tensors.Tensor], pivot: phiml.math._tensors.Tensor = None, dim='vector') -> ~GeometricType"
                },
                {
                    "name": "squared_length",
                    "qualname": "squared_length",
                    "docstring": "Returns the squared length of a vector `Tensor` or geometric object with a length-like property.\n\nArgs:\n    obj: `Tensor` with 'vector' dim or `Geometry` with a length-like property.\n\nReturns:\n    Squared length as `Tensor`",
                    "signature": "(obj: Union[phi.geom._geom.Geometry, phiml.math._tensors.Tensor]) -> phiml.math._tensors.Tensor"
                },
                {
                    "name": "stack",
                    "qualname": "stack",
                    "docstring": "Stacks `values` along the new dimension `dim`.\nAll values must have the same spatial, instance and channel dimensions. If the dimension sizes vary, the resulting tensor will be non-uniform.\nBatch dims will be added as needed.\n\nStacking tensors is performed lazily, i.e. the memory is allocated only when needed.\nThis makes repeated stacking and slicing along the same dimension very efficient, i.e. jit-compiled functions will not perform these operations.\n\nArgs:\n    values: Collection of `phiml.math.magic.Shapable`, such as `phiml.math.Tensor`\n        If a `dict`, keys must be of type `str` and are used as labels along `dim`.\n    dim: `Shape` with a least one dimension. None of these dims can be present with any of the `values`.\n        If `dim` is a single-dimension shape, its size is determined from `len(values)` and can be left undefined (`None`).\n        If `dim` is a multi-dimension shape, its volume must be equal to `len(values)`.\n    expand_values: If `True`, will first add missing dims to all values, not just batch dimensions.\n        This allows tensors with different dims to be stacked.\n        The resulting tensor will have all dims that are present in `values`.\n        If `False`, this may return a non-numeric object instead.\n    simplify: If `True` and all values are equal, returns one value without adding the dimension.\n    layout_non_matching: If non-matching values should be stacked using a Layout object, i.e. should be put into a named list instead.\n    **kwargs: Additional keyword arguments required by specific implementations.\n        Adding spatial dims to fields requires the `bounds: Box` argument specifying the physical extent of the new dimensions.\n        Adding batch dims must always work without keyword arguments.\n\nReturns:\n    `Tensor` containing `values` stacked along `dim`.\n\nExamples:\n    >>> stack({'x': 0, 'y': 1}, channel('vector'))\n    (x=0, y=1)\n\n    >>> stack([math.zeros(batch(b=2)), math.ones(batch(b=2))], channel(c='x,y'))\n    (x=0.000, y=1.000); (x=0.000, y=1.000) (b\u1d47=2, c\u1d9c=x,y)\n\n    >>> stack([vec(x=1, y=0), vec(x=2, y=3.)], batch('b'))\n    (x=1.000, y=0.000); (x=2.000, y=3.000) (b\u1d47=2, vector\u1d9c=x,y)",
                    "signature": "(values: Union[Sequence[~PhiTreeNodeType], Dict[str, ~PhiTreeNodeType]], dim: Union[phiml.math._shape.Shape, str], expand_values=False, simplify=False, layout_non_matching=False, **kwargs) -> ~PhiTreeNodeType"
                },
                {
                    "name": "surface_mesh",
                    "qualname": "surface_mesh",
                    "docstring": "Create a surface `Mesh` from a Geometry.\n\nArgs:\n    geo: `Geometry` to convert. Must implement `approximate_signed_distance`.\n    rel_dx: Relative mesh resolution as fraction of bounding box size.\n    abs_dx: Absolute mesh resolution. If both `rel_dx` and `abs_dx` are provided, the lower value is used.\n    method: 'auto' to select based on the type of `geo`. 'lewiner' or 'lorensen' for marching cubes.\n\nReturns:\n    `Mesh` if there is any geometry",
                    "signature": "(geo: phi.geom._geom.Geometry, rel_dx: float = None, abs_dx: float = None, method='auto') -> phi.geom._mesh.Mesh"
                },
                {
                    "name": "union",
                    "qualname": "union",
                    "docstring": "Union of the given geometries.\nA point lies inside the union if it lies within at least one of the geometries.\n\nArgs:\n    *geometries: arbitrary geometries with same spatial dims. Arbitrary batch dims are allowed.\n    dim: Union dimension. This must be an instance dimension.\n\nReturns:\n    union `Geometry`",
                    "signature": "(*geometries, dim=(union\u2071=None))"
                }
            ],
            "classes": [
                {
                    "name": "Box",
                    "qualname": "Box",
                    "docstring": "Simple cuboid defined by location of lower and upper corner in physical space.\n\nBoxes can be constructed either from two positional vector arguments `(lower, upper)` or by specifying the limits by dimension name as `kwargs`.\n\nExamples:\n    >>> Box(x=1, y=1)  # creates a two-dimensional unit box with `lower=(0, 0)` and `upper=(1, 1)`.\n    >>> Box(x=(None, 1), y=(0, None)  # creates a Box with `lower=(-inf, 0)` and `upper=(1, inf)`.\n\n    The slicing constructor was updated in version 2.2 and now requires the dimension order as the first argument.\n\n    >>> Box['x,y', 0:1, 0:1]  # creates a two-dimensional unit box with `lower=(0, 0)` and `upper=(1, 1)`.\n    >>> Box['x,y', :1, 0:]  # creates a Box with `lower=(-inf, 0)` and `upper=(1, inf)`.",
                    "signature": "(*args, **kwargs)",
                    "type": "class",
                    "methods": [
                        {
                            "name": "approximate_closest_surface",
                            "qualname": "Box.approximate_closest_surface",
                            "docstring": "Find the closest surface face of this geometry given a point that can be outside or inside the geometry.\n\nArgs:\n    location: `Tensor` with a single channel dimension called vector. Can have arbitrary other dimensions.\n\nReturns:\n    signed_distance: Scalar signed distance from `location`  to the closest point on the surface.\n        Positive values indicate the point lies outside the geometry, negative values indicate the point lies inside the geometry.\n    delta: Vector-valued distance vector from `location` to the closest point on the surface.\n    normal: Closest surface normal vector.\n    offset: Min distance of a surface-tangential plane from 0 as a scalar.\n    face_index: (Optional) An index vector pointing at the closest face.",
                            "signature": "(self, location: phiml.math._tensors.Tensor) -> Tuple[phiml.math._tensors.Tensor, phiml.math._tensors.Tensor, phiml.math._tensors.Tensor, phiml.math._tensors.Tensor, phiml.math._tensors.Tensor]"
                        },
                        {
                            "name": "approximate_signed_distance",
                            "qualname": "Box.approximate_signed_distance",
                            "docstring": "Computes the signed L-infinity norm (manhattan distance) from the location to the nearest side of the box.\nFor an outside location `l` with the closest surface point `s`, the distance is `max(abs(l - s))`.\nFor inside locations it is `-max(abs(l - s))`.\n\nArgs:\n  location: float tensor of shape (batch_size, ..., rank)\n\nReturns:\n  float tensor of shape (*location.shape[:-1], 1).",
                            "signature": "(self, location: Union[phiml.math._tensors.Tensor, tuple])"
                        },
                        {
                            "name": "at",
                            "qualname": "Box.at",
                            "docstring": "Returns a copy of this `Geometry` with the center at `center`.\nThis is equal to calling `self @ center`.\n\nSee Also:\n    `Geometry.shifted()`.\n\nArgs:\n    center: New center as `Tensor`.\n\nReturns:\n    `Geometry`.",
                            "signature": "(self, center: phiml.math._tensors.Tensor) -> 'Box'"
                        },
                        {
                            "name": "bounding_half_extent",
                            "qualname": "Box.bounding_half_extent",
                            "docstring": "The bounding half-extent sets a limit on the outer-most point for each coordinate axis.\nEach component is non-negative.\n\nLet the bounding half-extent have value `e` in dimension `d` (`extent[...,d] = e`).\nThen, no point of the geometry lies further away from its center point than `e` along `d` (in both axis directions).\n\nIf this geometry consists of multiple parts listed along instance/spatial dims, these dims are retained, giving the bounds of each part.\nIf these dims are not present on the result, all parts are assumed to have the same bounds.",
                            "signature": "(self) -> phiml.math._tensors.Tensor"
                        },
                        {
                            "name": "bounding_radius",
                            "qualname": "Box.bounding_radius",
                            "docstring": "Returns the radius of a Sphere object that fully encloses this geometry.\nThe sphere is centered at the center of this geometry.\n\nIf this geometry consists of multiple parts listed along instance/spatial dims, these dims are retained, giving the bounds of each part.\nIf these dims are not present on the result, all parts are assumed to have the same bounds.",
                            "signature": "(self)"
                        },
                        {
                            "name": "box",
                            "qualname": "Box.corner_representation",
                            "docstring": "",
                            "signature": "(self) -> 'Box'"
                        },
                        {
                            "name": "center_representation",
                            "qualname": "Box.center_representation",
                            "docstring": "",
                            "signature": "(self) -> 'Cuboid'"
                        },
                        {
                            "name": "contains",
                            "qualname": "Box.contains",
                            "docstring": "Tests if the other box lies fully inside this box.",
                            "signature": "(self, other: 'Box')"
                        },
                        {
                            "name": "corner_representation",
                            "qualname": "Box.corner_representation",
                            "docstring": "",
                            "signature": "(self) -> 'Box'"
                        },
                        {
                            "name": "cuboid",
                            "qualname": "Box.center_representation",
                            "docstring": "",
                            "signature": "(self) -> 'Cuboid'"
                        },
                        {
                            "name": "global_to_local",
                            "qualname": "Box.global_to_local",
                            "docstring": "Transform world-space coordinates into box-space coordinates.\n\nArgs:\n    global_position: World-space coordinates.\n    scale: Whether to re-scale the output so that [0, 1] or [-1, 1] represent the box for `origin='lower'` or `origin='center'`, respectively.\n    origin: 'lower' or 'center'\n\nReturns:\n    Box-space coordinate `Tensor`",
                            "signature": "(self, global_position: phiml.math._tensors.Tensor, scale=True, origin='lower') -> phiml.math._tensors.Tensor"
                        },
                        {
                            "name": "largest",
                            "qualname": "Box.largest",
                            "docstring": "",
                            "signature": "(self, dim: Union[str, Sequence, set, phiml.math._shape.Shape, Callable, NoneType]) -> 'Box'"
                        },
                        {
                            "name": "lies_inside",
                            "qualname": "Box.lies_inside",
                            "docstring": "Tests whether the given location lies inside or outside of the geometry. Locations on the surface count as inside.\n\nWhen dealing with unions or collections of geometries (instance dimensions), a point lies inside the geometry if it lies inside any instance.\n\nArgs:\n  location: float tensor of shape (batch_size, ..., rank)\n\nReturns:\n  bool tensor of shape (*location.shape[:-1], 1).",
                            "signature": "(self, location: phiml.math._tensors.Tensor) -> phiml.math._tensors.Tensor"
                        },
                        {
                            "name": "local_to_global",
                            "qualname": "Box.local_to_global",
                            "docstring": "",
                            "signature": "(self, local_position, scale=True, origin='lower')"
                        },
                        {
                            "name": "project",
                            "qualname": "Box.project",
                            "docstring": "Project this box into a lower-dimensional space.",
                            "signature": "(self, *dimensions: str)"
                        },
                        {
                            "name": "push",
                            "qualname": "Box.push",
                            "docstring": "Shifts positions either into or out of geometry.\n\nArgs:\n    positions: Tensor holding positions to shift\n    outward: Flag for indicating inward (False) or outward (True) shift\n    shift_amount: Minimum distance between positions and surface after shifting.\n\nReturns:\n    Tensor holding shifted positions.",
                            "signature": "(self, positions: phiml.math._tensors.Tensor, outward: bool = True, shift_amount: float = 0) -> phiml.math._tensors.Tensor"
                        },
                        {
                            "name": "rotated",
                            "qualname": "Box.rotated",
                            "docstring": "Returns a rotated version of this geometry.\nThe geometry is rotated about its center point.\n\nArgs:\n    angle: Delta rotation.\n        Either\n\n        * Angle(s): scalar angle in 2d or euler angles along `vector` in 3D or higher.\n        * Matrix: d\u2a2fd rotation matrix\n\nReturns:\n    Rotated `Geometry`",
                            "signature": "(self, angle) -> 'Box'"
                        },
                        {
                            "name": "sample_uniform",
                            "qualname": "Box.sample_uniform",
                            "docstring": "Samples uniformly distributed random points inside this volume.\n\nArgs:\n    *shape: How many points to sample per individual geometry.\n\nReturns:\n    `Tensor` containing all dimensions from `Geometry.shape`, `shape` as well as a `channel` dimension `vector` matching the dimensionality of this `Geometry`.",
                            "signature": "(self, *shape: phiml.math._shape.Shape) -> phiml.math._tensors.Tensor"
                        },
                        {
                            "name": "sample_uniform_surface",
                            "qualname": "Box.sample_uniform_surface",
                            "docstring": "",
                            "signature": "(self, *shape: phiml.math._shape.Shape) -> phiml.math._tensors.Tensor"
                        },
                        {
                            "name": "scaled",
                            "qualname": "Box.scaled",
                            "docstring": "Scales each individual geometry by `factor`.\nThe individual `center` points act as pivots for the operation.\n\nArgs:\n    factor:\n\nReturns:",
                            "signature": "(self, factor: Union[float, phiml.math._tensors.Tensor]) -> 'Box'"
                        },
                        {
                            "name": "smallest",
                            "qualname": "Box.smallest",
                            "docstring": "",
                            "signature": "(self, dim: Union[str, Sequence, set, phiml.math._shape.Shape, Callable, NoneType]) -> 'Box'"
                        },
                        {
                            "name": "without",
                            "qualname": "Box.without",
                            "docstring": "",
                            "signature": "(self, dims: Tuple[str, ...])"
                        }
                    ]
                },
                {
                    "name": "BaseBox",
                    "qualname": "Box",
                    "docstring": "Simple cuboid defined by location of lower and upper corner in physical space.\n\nBoxes can be constructed either from two positional vector arguments `(lower, upper)` or by specifying the limits by dimension name as `kwargs`.\n\nExamples:\n    >>> Box(x=1, y=1)  # creates a two-dimensional unit box with `lower=(0, 0)` and `upper=(1, 1)`.\n    >>> Box(x=(None, 1), y=(0, None)  # creates a Box with `lower=(-inf, 0)` and `upper=(1, inf)`.\n\n    The slicing constructor was updated in version 2.2 and now requires the dimension order as the first argument.\n\n    >>> Box['x,y', 0:1, 0:1]  # creates a two-dimensional unit box with `lower=(0, 0)` and `upper=(1, 1)`.\n    >>> Box['x,y', :1, 0:]  # creates a Box with `lower=(-inf, 0)` and `upper=(1, inf)`.",
                    "signature": "(*args, **kwargs)",
                    "type": "class",
                    "methods": [
                        {
                            "name": "approximate_closest_surface",
                            "qualname": "Box.approximate_closest_surface",
                            "docstring": "Find the closest surface face of this geometry given a point that can be outside or inside the geometry.\n\nArgs:\n    location: `Tensor` with a single channel dimension called vector. Can have arbitrary other dimensions.\n\nReturns:\n    signed_distance: Scalar signed distance from `location`  to the closest point on the surface.\n        Positive values indicate the point lies outside the geometry, negative values indicate the point lies inside the geometry.\n    delta: Vector-valued distance vector from `location` to the closest point on the surface.\n    normal: Closest surface normal vector.\n    offset: Min distance of a surface-tangential plane from 0 as a scalar.\n    face_index: (Optional) An index vector pointing at the closest face.",
                            "signature": "(self, location: phiml.math._tensors.Tensor) -> Tuple[phiml.math._tensors.Tensor, phiml.math._tensors.Tensor, phiml.math._tensors.Tensor, phiml.math._tensors.Tensor, phiml.math._tensors.Tensor]"
                        },
                        {
                            "name": "approximate_signed_distance",
                            "qualname": "Box.approximate_signed_distance",
                            "docstring": "Computes the signed L-infinity norm (manhattan distance) from the location to the nearest side of the box.\nFor an outside location `l` with the closest surface point `s`, the distance is `max(abs(l - s))`.\nFor inside locations it is `-max(abs(l - s))`.\n\nArgs:\n  location: float tensor of shape (batch_size, ..., rank)\n\nReturns:\n  float tensor of shape (*location.shape[:-1], 1).",
                            "signature": "(self, location: Union[phiml.math._tensors.Tensor, tuple])"
                        },
                        {
                            "name": "at",
                            "qualname": "Box.at",
                            "docstring": "Returns a copy of this `Geometry` with the center at `center`.\nThis is equal to calling `self @ center`.\n\nSee Also:\n    `Geometry.shifted()`.\n\nArgs:\n    center: New center as `Tensor`.\n\nReturns:\n    `Geometry`.",
                            "signature": "(self, center: phiml.math._tensors.Tensor) -> 'Box'"
                        },
                        {
                            "name": "bounding_half_extent",
                            "qualname": "Box.bounding_half_extent",
                            "docstring": "The bounding half-extent sets a limit on the outer-most point for each coordinate axis.\nEach component is non-negative.\n\nLet the bounding half-extent have value `e` in dimension `d` (`extent[...,d] = e`).\nThen, no point of the geometry lies further away from its center point than `e` along `d` (in both axis directions).\n\nIf this geometry consists of multiple parts listed along instance/spatial dims, these dims are retained, giving the bounds of each part.\nIf these dims are not present on the result, all parts are assumed to have the same bounds.",
                            "signature": "(self) -> phiml.math._tensors.Tensor"
                        },
                        {
                            "name": "bounding_radius",
                            "qualname": "Box.bounding_radius",
                            "docstring": "Returns the radius of a Sphere object that fully encloses this geometry.\nThe sphere is centered at the center of this geometry.\n\nIf this geometry consists of multiple parts listed along instance/spatial dims, these dims are retained, giving the bounds of each part.\nIf these dims are not present on the result, all parts are assumed to have the same bounds.",
                            "signature": "(self)"
                        },
                        {
                            "name": "box",
                            "qualname": "Box.corner_representation",
                            "docstring": "",
                            "signature": "(self) -> 'Box'"
                        },
                        {
                            "name": "center_representation",
                            "qualname": "Box.center_representation",
                            "docstring": "",
                            "signature": "(self) -> 'Cuboid'"
                        },
                        {
                            "name": "contains",
                            "qualname": "Box.contains",
                            "docstring": "Tests if the other box lies fully inside this box.",
                            "signature": "(self, other: 'Box')"
                        },
                        {
                            "name": "corner_representation",
                            "qualname": "Box.corner_representation",
                            "docstring": "",
                            "signature": "(self) -> 'Box'"
                        },
                        {
                            "name": "cuboid",
                            "qualname": "Box.center_representation",
                            "docstring": "",
                            "signature": "(self) -> 'Cuboid'"
                        },
                        {
                            "name": "global_to_local",
                            "qualname": "Box.global_to_local",
                            "docstring": "Transform world-space coordinates into box-space coordinates.\n\nArgs:\n    global_position: World-space coordinates.\n    scale: Whether to re-scale the output so that [0, 1] or [-1, 1] represent the box for `origin='lower'` or `origin='center'`, respectively.\n    origin: 'lower' or 'center'\n\nReturns:\n    Box-space coordinate `Tensor`",
                            "signature": "(self, global_position: phiml.math._tensors.Tensor, scale=True, origin='lower') -> phiml.math._tensors.Tensor"
                        },
                        {
                            "name": "largest",
                            "qualname": "Box.largest",
                            "docstring": "",
                            "signature": "(self, dim: Union[str, Sequence, set, phiml.math._shape.Shape, Callable, NoneType]) -> 'Box'"
                        },
                        {
                            "name": "lies_inside",
                            "qualname": "Box.lies_inside",
                            "docstring": "Tests whether the given location lies inside or outside of the geometry. Locations on the surface count as inside.\n\nWhen dealing with unions or collections of geometries (instance dimensions), a point lies inside the geometry if it lies inside any instance.\n\nArgs:\n  location: float tensor of shape (batch_size, ..., rank)\n\nReturns:\n  bool tensor of shape (*location.shape[:-1], 1).",
                            "signature": "(self, location: phiml.math._tensors.Tensor) -> phiml.math._tensors.Tensor"
                        },
                        {
                            "name": "local_to_global",
                            "qualname": "Box.local_to_global",
                            "docstring": "",
                            "signature": "(self, local_position, scale=True, origin='lower')"
                        },
                        {
                            "name": "project",
                            "qualname": "Box.project",
                            "docstring": "Project this box into a lower-dimensional space.",
                            "signature": "(self, *dimensions: str)"
                        },
                        {
                            "name": "push",
                            "qualname": "Box.push",
                            "docstring": "Shifts positions either into or out of geometry.\n\nArgs:\n    positions: Tensor holding positions to shift\n    outward: Flag for indicating inward (False) or outward (True) shift\n    shift_amount: Minimum distance between positions and surface after shifting.\n\nReturns:\n    Tensor holding shifted positions.",
                            "signature": "(self, positions: phiml.math._tensors.Tensor, outward: bool = True, shift_amount: float = 0) -> phiml.math._tensors.Tensor"
                        },
                        {
                            "name": "rotated",
                            "qualname": "Box.rotated",
                            "docstring": "Returns a rotated version of this geometry.\nThe geometry is rotated about its center point.\n\nArgs:\n    angle: Delta rotation.\n        Either\n\n        * Angle(s): scalar angle in 2d or euler angles along `vector` in 3D or higher.\n        * Matrix: d\u2a2fd rotation matrix\n\nReturns:\n    Rotated `Geometry`",
                            "signature": "(self, angle) -> 'Box'"
                        },
                        {
                            "name": "sample_uniform",
                            "qualname": "Box.sample_uniform",
                            "docstring": "Samples uniformly distributed random points inside this volume.\n\nArgs:\n    *shape: How many points to sample per individual geometry.\n\nReturns:\n    `Tensor` containing all dimensions from `Geometry.shape`, `shape` as well as a `channel` dimension `vector` matching the dimensionality of this `Geometry`.",
                            "signature": "(self, *shape: phiml.math._shape.Shape) -> phiml.math._tensors.Tensor"
                        },
                        {
                            "name": "sample_uniform_surface",
                            "qualname": "Box.sample_uniform_surface",
                            "docstring": "",
                            "signature": "(self, *shape: phiml.math._shape.Shape) -> phiml.math._tensors.Tensor"
                        },
                        {
                            "name": "scaled",
                            "qualname": "Box.scaled",
                            "docstring": "Scales each individual geometry by `factor`.\nThe individual `center` points act as pivots for the operation.\n\nArgs:\n    factor:\n\nReturns:",
                            "signature": "(self, factor: Union[float, phiml.math._tensors.Tensor]) -> 'Box'"
                        },
                        {
                            "name": "smallest",
                            "qualname": "Box.smallest",
                            "docstring": "",
                            "signature": "(self, dim: Union[str, Sequence, set, phiml.math._shape.Shape, Callable, NoneType]) -> 'Box'"
                        },
                        {
                            "name": "without",
                            "qualname": "Box.without",
                            "docstring": "",
                            "signature": "(self, dims: Tuple[str, ...])"
                        }
                    ]
                },
                {
                    "name": "Cylinder",
                    "qualname": "Cylinder",
                    "docstring": "N-dimensional cylinder.\nDefined by center position, radius, depth, alignment axis, rotation.\n\nFor cylinders whose bottom and top lie outside the domain or are otherwise not needed, you may use `infinite_cylinder` instead, which simplifies computations.",
                    "signature": "(_center: phiml.math._tensors.Tensor, radius: phiml.math._tensors.Tensor, depth: phiml.math._tensors.Tensor, rotation: phiml.math._tensors.Tensor, axis: str, variable_attrs: Tuple[str, ...] = ('_center', 'radius', 'depth', 'rotation'), value_attrs: Tuple[str, ...] = ()) -> None",
                    "type": "class",
                    "methods": [
                        {
                            "name": "approximate_closest_surface",
                            "qualname": "Cylinder.approximate_closest_surface",
                            "docstring": "Find the closest surface face of this geometry given a point that can be outside or inside the geometry.\n\nArgs:\n    location: `Tensor` with a single channel dimension called vector. Can have arbitrary other dimensions.\n\nReturns:\n    signed_distance: Scalar signed distance from `location`  to the closest point on the surface.\n        Positive values indicate the point lies outside the geometry, negative values indicate the point lies inside the geometry.\n    delta: Vector-valued distance vector from `location` to the closest point on the surface.\n    normal: Closest surface normal vector.\n    offset: Min distance of a surface-tangential plane from 0 as a scalar.\n    face_index: (Optional) An index vector pointing at the closest face.",
                            "signature": "(self, location: phiml.math._tensors.Tensor)"
                        },
                        {
                            "name": "approximate_signed_distance",
                            "qualname": "Cylinder.approximate_signed_distance",
                            "docstring": "Computes the approximate distance from location to the surface of the geometry.\nLocations outside return positive values, inside negative values and zero exactly at the boundary.\n\nThe exact distance metric used depends on the geometry.\nThe approximation holds close to the surface and the distance grows to infinity as the location is moved infinitely far from the geometry.\nThe distance metric is differentiable and its gradients are bounded at every point in space.\n\nWhen dealing with unions or collections of geometries (instance dimensions), the shortest distance to any instance is returned.\nThis also holds for negative distances.\n\nArgs:\n    location: `Tensor` with one channel dim `vector` matching the geometry's `vector` dim.\n\nReturns:\n    Float `Tensor`",
                            "signature": "(self, location: Union[phiml.math._tensors.Tensor, tuple])"
                        },
                        {
                            "name": "at",
                            "qualname": "Cylinder.at",
                            "docstring": "Returns a copy of this `Geometry` with the center at `center`.\nThis is equal to calling `self @ center`.\n\nSee Also:\n    `Geometry.shifted()`.\n\nArgs:\n    center: New center as `Tensor`.\n\nReturns:\n    `Geometry`.",
                            "signature": "(self, center: phiml.math._tensors.Tensor) -> 'Geometry'"
                        },
                        {
                            "name": "bounding_half_extent",
                            "qualname": "Cylinder.bounding_half_extent",
                            "docstring": "The bounding half-extent sets a limit on the outer-most point for each coordinate axis.\nEach component is non-negative.\n\nLet the bounding half-extent have value `e` in dimension `d` (`extent[...,d] = e`).\nThen, no point of the geometry lies further away from its center point than `e` along `d` (in both axis directions).\n\nIf this geometry consists of multiple parts listed along instance/spatial dims, these dims are retained, giving the bounds of each part.\nIf these dims are not present on the result, all parts are assumed to have the same bounds.",
                            "signature": "(self, epsilon=1e-05)"
                        },
                        {
                            "name": "bounding_radius",
                            "qualname": "Cylinder.bounding_radius",
                            "docstring": "Returns the radius of a Sphere object that fully encloses this geometry.\nThe sphere is centered at the center of this geometry.\n\nIf this geometry consists of multiple parts listed along instance/spatial dims, these dims are retained, giving the bounds of each part.\nIf these dims are not present on the result, all parts are assumed to have the same bounds.",
                            "signature": "(self)"
                        },
                        {
                            "name": "lies_inside",
                            "qualname": "Cylinder.lies_inside",
                            "docstring": "Tests whether the given location lies inside or outside of the geometry. Locations on the surface count as inside.\n\nWhen dealing with unions or collections of geometries (instance dimensions), a point lies inside the geometry if it lies inside any instance.\n\nArgs:\n  location: float tensor of shape (batch_size, ..., rank)\n\nReturns:\n  bool tensor of shape (*location.shape[:-1], 1).",
                            "signature": "(self, location)"
                        },
                        {
                            "name": "rotated",
                            "qualname": "Cylinder.rotated",
                            "docstring": "Returns a rotated version of this geometry.\nThe geometry is rotated about its center point.\n\nArgs:\n    angle: Delta rotation.\n        Either\n\n        * Angle(s): scalar angle in 2d or euler angles along `vector` in 3D or higher.\n        * Matrix: d\u2a2fd rotation matrix\n\nReturns:\n    Rotated `Geometry`",
                            "signature": "(self, angle)"
                        },
                        {
                            "name": "sample_uniform",
                            "qualname": "Cylinder.sample_uniform",
                            "docstring": "Samples uniformly distributed random points inside this volume.\n\nArgs:\n    *shape: How many points to sample per individual geometry.\n\nReturns:\n    `Tensor` containing all dimensions from `Geometry.shape`, `shape` as well as a `channel` dimension `vector` matching the dimensionality of this `Geometry`.",
                            "signature": "(self, *shape: phiml.math._shape.Shape)"
                        },
                        {
                            "name": "scaled",
                            "qualname": "Cylinder.scaled",
                            "docstring": "Scales each individual geometry by `factor`.\nThe individual `center` points act as pivots for the operation.\n\nArgs:\n    factor:\n\nReturns:",
                            "signature": "(self, factor: Union[float, phiml.math._tensors.Tensor]) -> 'Geometry'"
                        },
                        {
                            "name": "vertex_rings",
                            "qualname": "Cylinder.vertex_rings",
                            "docstring": "",
                            "signature": "(self, count: phiml.math._shape.Shape) -> phiml.math._tensors.Tensor"
                        },
                        {
                            "name": "with_depth",
                            "qualname": "Cylinder.with_depth",
                            "docstring": "",
                            "signature": "(self, depth: phiml.math._tensors.Tensor) -> 'Cylinder'"
                        },
                        {
                            "name": "with_radius",
                            "qualname": "Cylinder.with_radius",
                            "docstring": "",
                            "signature": "(self, radius: phiml.math._tensors.Tensor) -> 'Cylinder'"
                        }
                    ]
                },
                {
                    "name": "Geometry",
                    "qualname": "Geometry",
                    "docstring": "Abstract base class for N-dimensional shapes.\n\nMain implementing classes:\n\n* `Sphere`\n* `Box`\n* `Cylinder`\n* `Graph`\n* `Mesh`\n* `Heightmap`\n* `SDFGrid`\n* `SDF`\n* `SplineSheet`\n\nAll geometry objects support batching.\nThereby any parameter defining the geometry can be varied along arbitrary batch dims.\nAll batch dimensions are listed in Geometry.shape.\n\nProperty getters (`@property`, such as `shape`), save for getters, must not depend on any variables marked as *variable* via `__variable_attrs__()` as these may be `None` during tracing.\nEquality checks must also take this into account.",
                    "signature": "()",
                    "type": "class",
                    "methods": [
                        {
                            "name": "approximate_closest_surface",
                            "qualname": "Geometry.approximate_closest_surface",
                            "docstring": "Find the closest surface face of this geometry given a point that can be outside or inside the geometry.\n\nArgs:\n    location: `Tensor` with a single channel dimension called vector. Can have arbitrary other dimensions.\n\nReturns:\n    signed_distance: Scalar signed distance from `location`  to the closest point on the surface.\n        Positive values indicate the point lies outside the geometry, negative values indicate the point lies inside the geometry.\n    delta: Vector-valued distance vector from `location` to the closest point on the surface.\n    normal: Closest surface normal vector.\n    offset: Min distance of a surface-tangential plane from 0 as a scalar.\n    face_index: (Optional) An index vector pointing at the closest face.",
                            "signature": "(self, location: phiml.math._tensors.Tensor) -> Tuple[phiml.math._tensors.Tensor, phiml.math._tensors.Tensor, phiml.math._tensors.Tensor, phiml.math._tensors.Tensor, phiml.math._tensors.Tensor]"
                        },
                        {
                            "name": "approximate_fraction_inside",
                            "qualname": "Geometry.approximate_fraction_inside",
                            "docstring": "Computes the approximate overlap between the geometry and a small other geometry.\nReturns 1.0 if `other_geometry` is fully enclosed in this geometry and 0.0 if there is no overlap.\nClose to the surface of this geometry, the fraction filled is differentiable w.r.t. the location and size of `other_geometry`.\n\nTo call this method on batches of geometries of same shape, pass a batched Geometry instance.\nThe result tensor will match the batch shape of `other_geometry`.\n\nThe result may only be accurate in special cases.\nThe given geometries may be approximated as spheres or boxes using `bounding_radius()` and `bounding_half_extent()`.\n\nThe default implementation of this method approximates other_geometry as a Sphere and computes the fraction using `approximate_signed_distance()`.\n\nArgs:\n    other_geometry: `Geometry` or geometry batch for which to compute the overlap with `self`.\n    balance: Mid-level between 0 and 1, default 0.5.\n        This value is returned when exactly half of `other_geometry` lies inside `self`.\n        `0.5 < balance <= 1` makes `self` seem larger while `0 <= balance < 0.5`makes `self` seem smaller.\n\nReturns:\n  fraction of cell volume lying inside the geometry. float tensor of shape (other_geometry.batch_shape, 1).",
                            "signature": "(self, other_geometry: 'Geometry', balance: Union[phiml.math._tensors.Tensor, numbers.Number] = 0.5) -> phiml.math._tensors.Tensor"
                        },
                        {
                            "name": "approximate_signed_distance",
                            "qualname": "Geometry.approximate_signed_distance",
                            "docstring": "Computes the approximate distance from location to the surface of the geometry.\nLocations outside return positive values, inside negative values and zero exactly at the boundary.\n\nThe exact distance metric used depends on the geometry.\nThe approximation holds close to the surface and the distance grows to infinity as the location is moved infinitely far from the geometry.\nThe distance metric is differentiable and its gradients are bounded at every point in space.\n\nWhen dealing with unions or collections of geometries (instance dimensions), the shortest distance to any instance is returned.\nThis also holds for negative distances.\n\nArgs:\n    location: `Tensor` with one channel dim `vector` matching the geometry's `vector` dim.\n\nReturns:\n    Float `Tensor`",
                            "signature": "(self, location: phiml.math._tensors.Tensor) -> phiml.math._tensors.Tensor"
                        },
                        {
                            "name": "at",
                            "qualname": "Geometry.at",
                            "docstring": "Returns a copy of this `Geometry` with the center at `center`.\nThis is equal to calling `self @ center`.\n\nSee Also:\n    `Geometry.shifted()`.\n\nArgs:\n    center: New center as `Tensor`.\n\nReturns:\n    `Geometry`.",
                            "signature": "(self, center: phiml.math._tensors.Tensor) -> 'Geometry'"
                        },
                        {
                            "name": "bounding_box",
                            "qualname": "Geometry.bounding_box",
                            "docstring": "Returns the approximately smallest axis-aligned box that contains this `Geometry`.\nThe center of the box may not be equal to `self.center`.\n\nReturns:\n    `Box` or `Cuboid` that fully contains this `Geometry`.",
                            "signature": "(self)"
                        },
                        {
                            "name": "bounding_half_extent",
                            "qualname": "Geometry.bounding_half_extent",
                            "docstring": "The bounding half-extent sets a limit on the outer-most point for each coordinate axis.\nEach component is non-negative.\n\nLet the bounding half-extent have value `e` in dimension `d` (`extent[...,d] = e`).\nThen, no point of the geometry lies further away from its center point than `e` along `d` (in both axis directions).\n\nIf this geometry consists of multiple parts listed along instance/spatial dims, these dims are retained, giving the bounds of each part.\nIf these dims are not present on the result, all parts are assumed to have the same bounds.",
                            "signature": "(self) -> phiml.math._tensors.Tensor"
                        },
                        {
                            "name": "bounding_radius",
                            "qualname": "Geometry.bounding_radius",
                            "docstring": "Returns the radius of a Sphere object that fully encloses this geometry.\nThe sphere is centered at the center of this geometry.\n\nIf this geometry consists of multiple parts listed along instance/spatial dims, these dims are retained, giving the bounds of each part.\nIf these dims are not present on the result, all parts are assumed to have the same bounds.",
                            "signature": "(self) -> phiml.math._tensors.Tensor"
                        },
                        {
                            "name": "bounding_sphere",
                            "qualname": "Geometry.bounding_sphere",
                            "docstring": "",
                            "signature": "(self)"
                        },
                        {
                            "name": "get_boundary",
                            "qualname": "Geometry.get_boundary",
                            "docstring": "",
                            "signature": "(self, set_key: str) -> Dict[str, Dict[str, slice]]"
                        },
                        {
                            "name": "get_points",
                            "qualname": "Geometry.get_points",
                            "docstring": "",
                            "signature": "(self, set_key: str) -> phiml.math._tensors.Tensor"
                        },
                        {
                            "name": "integrate_flux",
                            "qualname": "Geometry.integrate_flux",
                            "docstring": "",
                            "signature": "(self, flux: phiml.math._tensors.Tensor, divide_volume=False) -> phiml.math._tensors.Tensor"
                        },
                        {
                            "name": "integrate_surface",
                            "qualname": "Geometry.integrate_surface",
                            "docstring": "Multiplies `values\u00b4 by the corresponding face area, computes the sum over all faces and divides by the cell volume.\n\u2211 values * A.\n\nArgs:\n    face_values: Values sampled at the face centers.\n    divide_volume: Whether to divide by the cell `volume\u00b4\n\nReturns:\n    `Tensor` of values sampled at the centroids.",
                            "signature": "(self, face_values: phiml.math._tensors.Tensor, divide_volume=False) -> phiml.math._tensors.Tensor"
                        },
                        {
                            "name": "lies_inside",
                            "qualname": "Geometry.lies_inside",
                            "docstring": "Tests whether the given location lies inside or outside of the geometry. Locations on the surface count as inside.\n\nWhen dealing with unions or collections of geometries (instance dimensions), a point lies inside the geometry if it lies inside any instance.\n\nArgs:\n  location: float tensor of shape (batch_size, ..., rank)\n\nReturns:\n  bool tensor of shape (*location.shape[:-1], 1).",
                            "signature": "(self, location: phiml.math._tensors.Tensor) -> phiml.math._tensors.Tensor"
                        },
                        {
                            "name": "push",
                            "qualname": "Geometry.push",
                            "docstring": "Shifts positions either into or out of geometry.\n\nArgs:\n    positions: Tensor holding positions to shift\n    outward: Flag for indicating inward (False) or outward (True) shift\n    shift_amount: Minimum distance between positions and surface after shifting.\n\nReturns:\n    Tensor holding shifted positions.",
                            "signature": "(self, positions: phiml.math._tensors.Tensor, outward: bool = True, shift_amount: float = 0) -> phiml.math._tensors.Tensor"
                        },
                        {
                            "name": "rotated",
                            "qualname": "Geometry.rotated",
                            "docstring": "Returns a rotated version of this geometry.\nThe geometry is rotated about its center point.\n\nArgs:\n    angle: Delta rotation.\n        Either\n\n        * Angle(s): scalar angle in 2d or euler angles along `vector` in 3D or higher.\n        * Matrix: d\u2a2fd rotation matrix\n\nReturns:\n    Rotated `Geometry`",
                            "signature": "(self, angle: Union[float, phiml.math._tensors.Tensor]) -> 'Geometry'"
                        },
                        {
                            "name": "sample_uniform",
                            "qualname": "Geometry.sample_uniform",
                            "docstring": "Samples uniformly distributed random points inside this volume.\n\nArgs:\n    *shape: How many points to sample per individual geometry.\n\nReturns:\n    `Tensor` containing all dimensions from `Geometry.shape`, `shape` as well as a `channel` dimension `vector` matching the dimensionality of this `Geometry`.",
                            "signature": "(self, *shape: phiml.math._shape.Shape) -> phiml.math._tensors.Tensor"
                        },
                        {
                            "name": "scaled",
                            "qualname": "Geometry.scaled",
                            "docstring": "Scales each individual geometry by `factor`.\nThe individual `center` points act as pivots for the operation.\n\nArgs:\n    factor:\n\nReturns:",
                            "signature": "(self, factor: Union[float, phiml.math._tensors.Tensor]) -> 'Geometry'"
                        },
                        {
                            "name": "shallow_equals",
                            "qualname": "Geometry.shallow_equals",
                            "docstring": "Quick equality check.\nMay return `False` even if `other == self`.\nHowever, if `True` is returned, the geometries are guaranteed to be equal.\n\nThe `shallow_equals()` check does not compare all tensor elements but merely checks whether the same tensors are referenced.",
                            "signature": "(self, other)"
                        },
                        {
                            "name": "shifted",
                            "qualname": "Geometry.shifted",
                            "docstring": "Returns a translated version of this geometry.\n\nSee Also:\n    `Geometry.at()`.\n\nArgs:\n  delta: direction vector\n  delta: Tensor:\n\nReturns:\n  Geometry: shifted geometry",
                            "signature": "(self, delta: phiml.math._tensors.Tensor) -> 'Geometry'"
                        },
                        {
                            "name": "unstack",
                            "qualname": "Geometry.unstack",
                            "docstring": "Unstacks this Geometry along the given dimension.\nThe shapes of the returned geometries are reduced by `dimension`.\n\nArgs:\n    dimension: dimension along which to unstack\n\nReturns:\n    geometries: tuple of length equal to `geometry.shape.get_size(dimension)`",
                            "signature": "(self, dimension: str) -> tuple"
                        }
                    ]
                },
                {
                    "name": "GeometryException",
                    "qualname": "GeometryException",
                    "docstring": "Raised when an operation is fundamentally not possible for a `Geometry`.\nPossible causes:\n\n* Trying to get the interior of a non-surface `Geometry`\n* Trying to get the surface of a point-like `Geometry`",
                    "signature": "Error getting signature: ValueError",
                    "type": "class",
                    "methods": []
                },
                {
                    "name": "Graph",
                    "qualname": "Graph",
                    "docstring": "A graph consists of multiple geometry nodes and corresponding edge information.\n\nEdges are stored as a Tensor with the same axes ad `geometry` plus their dual counterparts.\nAdditional dimensions can be added to `edges` to store vector-valued connectivity weights.",
                    "signature": "(nodes: phi.geom._geom.Geometry, edges: phiml.math._tensors.Tensor, boundary: Dict[str, Dict[str, slice]]) -> None",
                    "type": "class",
                    "methods": [
                        {
                            "name": "approximate_closest_surface",
                            "qualname": "Graph.approximate_closest_surface",
                            "docstring": "Find the closest surface face of this geometry given a point that can be outside or inside the geometry.\n\nArgs:\n    location: `Tensor` with a single channel dimension called vector. Can have arbitrary other dimensions.\n\nReturns:\n    signed_distance: Scalar signed distance from `location`  to the closest point on the surface.\n        Positive values indicate the point lies outside the geometry, negative values indicate the point lies inside the geometry.\n    delta: Vector-valued distance vector from `location` to the closest point on the surface.\n    normal: Closest surface normal vector.\n    offset: Min distance of a surface-tangential plane from 0 as a scalar.\n    face_index: (Optional) An index vector pointing at the closest face.",
                            "signature": "(self, location: phiml.math._tensors.Tensor) -> Tuple[phiml.math._tensors.Tensor, phiml.math._tensors.Tensor, phiml.math._tensors.Tensor, phiml.math._tensors.Tensor, phiml.math._tensors.Tensor]"
                        },
                        {
                            "name": "approximate_signed_distance",
                            "qualname": "Graph.approximate_signed_distance",
                            "docstring": "Computes the approximate distance from location to the surface of the geometry.\nLocations outside return positive values, inside negative values and zero exactly at the boundary.\n\nThe exact distance metric used depends on the geometry.\nThe approximation holds close to the surface and the distance grows to infinity as the location is moved infinitely far from the geometry.\nThe distance metric is differentiable and its gradients are bounded at every point in space.\n\nWhen dealing with unions or collections of geometries (instance dimensions), the shortest distance to any instance is returned.\nThis also holds for negative distances.\n\nArgs:\n    location: `Tensor` with one channel dim `vector` matching the geometry's `vector` dim.\n\nReturns:\n    Float `Tensor`",
                            "signature": "(self, location: phiml.math._tensors.Tensor) -> phiml.math._tensors.Tensor"
                        },
                        {
                            "name": "as_points",
                            "qualname": "Graph.as_points",
                            "docstring": "",
                            "signature": "(self)"
                        },
                        {
                            "name": "at",
                            "qualname": "Graph.at",
                            "docstring": "Returns a copy of this `Geometry` with the center at `center`.\nThis is equal to calling `self @ center`.\n\nSee Also:\n    `Geometry.shifted()`.\n\nArgs:\n    center: New center as `Tensor`.\n\nReturns:\n    `Geometry`.",
                            "signature": "(self, center: phiml.math._tensors.Tensor) -> 'Geometry'"
                        },
                        {
                            "name": "bounding_half_extent",
                            "qualname": "Graph.bounding_half_extent",
                            "docstring": "The bounding half-extent sets a limit on the outer-most point for each coordinate axis.\nEach component is non-negative.\n\nLet the bounding half-extent have value `e` in dimension `d` (`extent[...,d] = e`).\nThen, no point of the geometry lies further away from its center point than `e` along `d` (in both axis directions).\n\nIf this geometry consists of multiple parts listed along instance/spatial dims, these dims are retained, giving the bounds of each part.\nIf these dims are not present on the result, all parts are assumed to have the same bounds.",
                            "signature": "(self) -> phiml.math._tensors.Tensor"
                        },
                        {
                            "name": "bounding_radius",
                            "qualname": "Graph.bounding_radius",
                            "docstring": "Returns the radius of a Sphere object that fully encloses this geometry.\nThe sphere is centered at the center of this geometry.\n\nIf this geometry consists of multiple parts listed along instance/spatial dims, these dims are retained, giving the bounds of each part.\nIf these dims are not present on the result, all parts are assumed to have the same bounds.",
                            "signature": "(self) -> phiml.math._tensors.Tensor"
                        },
                        {
                            "name": "lies_inside",
                            "qualname": "Graph.lies_inside",
                            "docstring": "Tests whether the given location lies inside or outside of the geometry. Locations on the surface count as inside.\n\nWhen dealing with unions or collections of geometries (instance dimensions), a point lies inside the geometry if it lies inside any instance.\n\nArgs:\n  location: float tensor of shape (batch_size, ..., rank)\n\nReturns:\n  bool tensor of shape (*location.shape[:-1], 1).",
                            "signature": "(self, location: phiml.math._tensors.Tensor) -> phiml.math._tensors.Tensor"
                        },
                        {
                            "name": "rotated",
                            "qualname": "Graph.rotated",
                            "docstring": "Returns a rotated version of this geometry.\nThe geometry is rotated about its center point.\n\nArgs:\n    angle: Delta rotation.\n        Either\n\n        * Angle(s): scalar angle in 2d or euler angles along `vector` in 3D or higher.\n        * Matrix: d\u2a2fd rotation matrix\n\nReturns:\n    Rotated `Geometry`",
                            "signature": "(self, angle: Union[float, phiml.math._tensors.Tensor]) -> 'Geometry'"
                        },
                        {
                            "name": "sample_uniform",
                            "qualname": "Graph.sample_uniform",
                            "docstring": "Samples uniformly distributed random points inside this volume.\n\nArgs:\n    *shape: How many points to sample per individual geometry.\n\nReturns:\n    `Tensor` containing all dimensions from `Geometry.shape`, `shape` as well as a `channel` dimension `vector` matching the dimensionality of this `Geometry`.",
                            "signature": "(self, *shape: phiml.math._shape.Shape) -> phiml.math._tensors.Tensor"
                        },
                        {
                            "name": "scaled",
                            "qualname": "Graph.scaled",
                            "docstring": "Scales each individual geometry by `factor`.\nThe individual `center` points act as pivots for the operation.\n\nArgs:\n    factor:\n\nReturns:",
                            "signature": "(self, factor: Union[float, phiml.math._tensors.Tensor]) -> 'Geometry'"
                        },
                        {
                            "name": "shifted",
                            "qualname": "Graph.shifted",
                            "docstring": "Returns a translated version of this geometry.\n\nSee Also:\n    `Geometry.at()`.\n\nArgs:\n  delta: direction vector\n  delta: Tensor:\n\nReturns:\n  Geometry: shifted geometry",
                            "signature": "(self, delta: phiml.math._tensors.Tensor) -> 'Geometry'"
                        }
                    ]
                },
                {
                    "name": "Heightmap",
                    "qualname": "Heightmap",
                    "docstring": "Abstract base class for N-dimensional shapes.\n\nMain implementing classes:\n\n* `Sphere`\n* `Box`\n* `Cylinder`\n* `Graph`\n* `Mesh`\n* `Heightmap`\n* `SDFGrid`\n* `SDF`\n* `SplineSheet`\n\nAll geometry objects support batching.\nThereby any parameter defining the geometry can be varied along arbitrary batch dims.\nAll batch dimensions are listed in Geometry.shape.\n\nProperty getters (`@property`, such as `shape`), save for getters, must not depend on any variables marked as *variable* via `__variable_attrs__()` as these may be `None` during tracing.\nEquality checks must also take this into account.\n\nArgs:\n    height: Heightmap `Tensor` of absolute (world-space) height values.\n        Scalar height values on a d-1 dimensional grid.\n    bounds: d-dimensional bounds.\n        Locations outside `bounds' can never lie inside this geometry if `extrapolation is None`.\n        Otherwise, only the height dimension is checked.\n        The grid dimensions of `bounds` must be finite but the height dimension may be infinite to count all values above/below `height` as inside.\n    max_dist: Maximum distance up to which the distance approximations should be valid.\n        This does not affect the number of computations performed to compute the distance.\n        Low values increase accuracy close to the surface but trade off possibly very wrong distances further away.\n    fill_below: Whether the inside is below or above the height values.\n    extrapolation: Surface height outside `bounds\u00b4. Can be any valid `phiml.math.Extrapolation`, such as a constant.\n        If not `None`, values outside `bounds` will be checked against the extrapolated `height` values.\n        Otherwise, values outside `bounds` always lie on the outside.",
                    "signature": "(height: phiml.math._tensors.Tensor, bounds: phi.geom._box.Box, max_dist: Union[float, phiml.math._tensors.Tensor], fill_below: Union[bool, phiml.math._tensors.Tensor] = True, extrapolation: Union[float, str, phiml.math.extrapolation.Extrapolation] = None, faces=None)",
                    "type": "class",
                    "methods": [
                        {
                            "name": "approximate_closest_surface",
                            "qualname": "Heightmap.approximate_closest_surface",
                            "docstring": "Find the closest surface face of this geometry given a point that can be outside or inside the geometry.\n\nArgs:\n    location: `Tensor` with a single channel dimension called vector. Can have arbitrary other dimensions.\n\nReturns:\n    signed_distance: Scalar signed distance from `location`  to the closest point on the surface.\n        Positive values indicate the point lies outside the geometry, negative values indicate the point lies inside the geometry.\n    delta: Vector-valued distance vector from `location` to the closest point on the surface.\n    normal: Closest surface normal vector.\n    offset: Min distance of a surface-tangential plane from 0 as a scalar.\n    face_index: (Optional) An index vector pointing at the closest face.",
                            "signature": "(self, location: phiml.math._tensors.Tensor) -> Tuple[phiml.math._tensors.Tensor, phiml.math._tensors.Tensor, phiml.math._tensors.Tensor, phiml.math._tensors.Tensor, phiml.math._tensors.Tensor]"
                        },
                        {
                            "name": "approximate_signed_distance",
                            "qualname": "Heightmap.approximate_signed_distance",
                            "docstring": "Computes the approximate distance from location to the surface of the geometry.\nLocations outside return positive values, inside negative values and zero exactly at the boundary.\n\nThe exact distance metric used depends on the geometry.\nThe approximation holds close to the surface and the distance grows to infinity as the location is moved infinitely far from the geometry.\nThe distance metric is differentiable and its gradients are bounded at every point in space.\n\nWhen dealing with unions or collections of geometries (instance dimensions), the shortest distance to any instance is returned.\nThis also holds for negative distances.\n\nArgs:\n    location: `Tensor` with one channel dim `vector` matching the geometry's `vector` dim.\n\nReturns:\n    Float `Tensor`",
                            "signature": "(self, location: phiml.math._tensors.Tensor) -> phiml.math._tensors.Tensor"
                        },
                        {
                            "name": "at",
                            "qualname": "Heightmap.at",
                            "docstring": "Returns a copy of this `Geometry` with the center at `center`.\nThis is equal to calling `self @ center`.\n\nSee Also:\n    `Geometry.shifted()`.\n\nArgs:\n    center: New center as `Tensor`.\n\nReturns:\n    `Geometry`.",
                            "signature": "(self, center: phiml.math._tensors.Tensor) -> 'Geometry'"
                        },
                        {
                            "name": "bounding_half_extent",
                            "qualname": "Heightmap.bounding_half_extent",
                            "docstring": "The bounding half-extent sets a limit on the outer-most point for each coordinate axis.\nEach component is non-negative.\n\nLet the bounding half-extent have value `e` in dimension `d` (`extent[...,d] = e`).\nThen, no point of the geometry lies further away from its center point than `e` along `d` (in both axis directions).\n\nIf this geometry consists of multiple parts listed along instance/spatial dims, these dims are retained, giving the bounds of each part.\nIf these dims are not present on the result, all parts are assumed to have the same bounds.",
                            "signature": "(self) -> phiml.math._tensors.Tensor"
                        },
                        {
                            "name": "bounding_radius",
                            "qualname": "Heightmap.bounding_radius",
                            "docstring": "Returns the radius of a Sphere object that fully encloses this geometry.\nThe sphere is centered at the center of this geometry.\n\nIf this geometry consists of multiple parts listed along instance/spatial dims, these dims are retained, giving the bounds of each part.\nIf these dims are not present on the result, all parts are assumed to have the same bounds.",
                            "signature": "(self) -> phiml.math._tensors.Tensor"
                        },
                        {
                            "name": "lies_inside",
                            "qualname": "Heightmap.lies_inside",
                            "docstring": "Tests whether the given location lies inside or outside of the geometry. Locations on the surface count as inside.\n\nWhen dealing with unions or collections of geometries (instance dimensions), a point lies inside the geometry if it lies inside any instance.\n\nArgs:\n  location: float tensor of shape (batch_size, ..., rank)\n\nReturns:\n  bool tensor of shape (*location.shape[:-1], 1).",
                            "signature": "(self, location: phiml.math._tensors.Tensor) -> phiml.math._tensors.Tensor"
                        },
                        {
                            "name": "rotated",
                            "qualname": "Heightmap.rotated",
                            "docstring": "Returns a rotated version of this geometry.\nThe geometry is rotated about its center point.\n\nArgs:\n    angle: Delta rotation.\n        Either\n\n        * Angle(s): scalar angle in 2d or euler angles along `vector` in 3D or higher.\n        * Matrix: d\u2a2fd rotation matrix\n\nReturns:\n    Rotated `Geometry`",
                            "signature": "(self, angle: Union[float, phiml.math._tensors.Tensor]) -> 'Geometry'"
                        },
                        {
                            "name": "sample_uniform",
                            "qualname": "Heightmap.sample_uniform",
                            "docstring": "Samples uniformly distributed random points inside this volume.\n\nArgs:\n    *shape: How many points to sample per individual geometry.\n\nReturns:\n    `Tensor` containing all dimensions from `Geometry.shape`, `shape` as well as a `channel` dimension `vector` matching the dimensionality of this `Geometry`.",
                            "signature": "(self, *shape: phiml.math._shape.Shape) -> phiml.math._tensors.Tensor"
                        },
                        {
                            "name": "scaled",
                            "qualname": "Heightmap.scaled",
                            "docstring": "Scales each individual geometry by `factor`.\nThe individual `center` points act as pivots for the operation.\n\nArgs:\n    factor:\n\nReturns:",
                            "signature": "(self, factor: Union[float, phiml.math._tensors.Tensor]) -> 'Geometry'"
                        },
                        {
                            "name": "shallow_equals",
                            "qualname": "Heightmap.shallow_equals",
                            "docstring": "Quick equality check.\nMay return `False` even if `other == self`.\nHowever, if `True` is returned, the geometries are guaranteed to be equal.\n\nThe `shallow_equals()` check does not compare all tensor elements but merely checks whether the same tensors are referenced.",
                            "signature": "(self, other)"
                        }
                    ]
                },
                {
                    "name": "Mesh",
                    "qualname": "Mesh",
                    "docstring": "Unstructured mesh, consisting of vertices and elements.\n\nUse `phi.geom.mesh()` or `phi.geom.mesh_from_numpy()` to construct a mesh manually or `phi.geom.load_su2()` to load one from a file.",
                    "signature": "(vertices: phi.geom._geom.Geometry, elements: phiml.math._tensors.Tensor, element_rank: int, boundaries: Dict[str, Dict[str, slice]], periodic: Sequence[str], face_format: str = 'csc', max_cell_walk: int = None, variable_attrs: Tuple[str, ...] = ('vertices',), value_attrs: Tuple[str, ...] = ()) -> None",
                    "type": "class",
                    "methods": [
                        {
                            "name": "approximate_closest_surface",
                            "qualname": "Mesh.approximate_closest_surface",
                            "docstring": "Find the closest surface face of this geometry given a point that can be outside or inside the geometry.\n\nArgs:\n    location: `Tensor` with a single channel dimension called vector. Can have arbitrary other dimensions.\n\nReturns:\n    signed_distance: Scalar signed distance from `location`  to the closest point on the surface.\n        Positive values indicate the point lies outside the geometry, negative values indicate the point lies inside the geometry.\n    delta: Vector-valued distance vector from `location` to the closest point on the surface.\n    normal: Closest surface normal vector.\n    offset: Min distance of a surface-tangential plane from 0 as a scalar.\n    face_index: (Optional) An index vector pointing at the closest face.",
                            "signature": "(self, location: phiml.math._tensors.Tensor) -> Tuple[phiml.math._tensors.Tensor, phiml.math._tensors.Tensor, phiml.math._tensors.Tensor, phiml.math._tensors.Tensor, phiml.math._tensors.Tensor]"
                        },
                        {
                            "name": "approximate_signed_distance",
                            "qualname": "Mesh.approximate_signed_distance",
                            "docstring": "Computes the approximate distance from location to the surface of the geometry.\nLocations outside return positive values, inside negative values and zero exactly at the boundary.\n\nThe exact distance metric used depends on the geometry.\nThe approximation holds close to the surface and the distance grows to infinity as the location is moved infinitely far from the geometry.\nThe distance metric is differentiable and its gradients are bounded at every point in space.\n\nWhen dealing with unions or collections of geometries (instance dimensions), the shortest distance to any instance is returned.\nThis also holds for negative distances.\n\nArgs:\n    location: `Tensor` with one channel dim `vector` matching the geometry's `vector` dim.\n\nReturns:\n    Float `Tensor`",
                            "signature": "(self, location: Union[phiml.math._tensors.Tensor, tuple]) -> phiml.math._tensors.Tensor"
                        },
                        {
                            "name": "at",
                            "qualname": "Mesh.at",
                            "docstring": "Returns a copy of this `Geometry` with the center at `center`.\nThis is equal to calling `self @ center`.\n\nSee Also:\n    `Geometry.shifted()`.\n\nArgs:\n    center: New center as `Tensor`.\n\nReturns:\n    `Geometry`.",
                            "signature": "(self, center: phiml.math._tensors.Tensor) -> 'Mesh'"
                        },
                        {
                            "name": "bounding_box",
                            "qualname": "Mesh.bounding_box",
                            "docstring": "Returns the approximately smallest axis-aligned box that contains this `Geometry`.\nThe center of the box may not be equal to `self.center`.\n\nReturns:\n    `Box` or `Cuboid` that fully contains this `Geometry`.",
                            "signature": "(self) -> 'Box'"
                        },
                        {
                            "name": "bounding_half_extent",
                            "qualname": "Mesh.bounding_half_extent",
                            "docstring": "The bounding half-extent sets a limit on the outer-most point for each coordinate axis.\nEach component is non-negative.\n\nLet the bounding half-extent have value `e` in dimension `d` (`extent[...,d] = e`).\nThen, no point of the geometry lies further away from its center point than `e` along `d` (in both axis directions).\n\nIf this geometry consists of multiple parts listed along instance/spatial dims, these dims are retained, giving the bounds of each part.\nIf these dims are not present on the result, all parts are assumed to have the same bounds.",
                            "signature": "(self) -> phiml.math._tensors.Tensor"
                        },
                        {
                            "name": "bounding_radius",
                            "qualname": "Mesh.bounding_radius",
                            "docstring": "Returns the radius of a Sphere object that fully encloses this geometry.\nThe sphere is centered at the center of this geometry.\n\nIf this geometry consists of multiple parts listed along instance/spatial dims, these dims are retained, giving the bounds of each part.\nIf these dims are not present on the result, all parts are assumed to have the same bounds.",
                            "signature": "(self) -> phiml.math._tensors.Tensor"
                        },
                        {
                            "name": "cell_walk_towards",
                            "qualname": "Mesh.cell_walk_towards",
                            "docstring": "If `location` is not within the cell at index `from_cell_idx`, moves to a closer neighbor cell.\n\nArgs:\n    location: Target location as `Tensor`.\n    start_cell_idx: Index of starting cell. Must be a valid cell index.\n    allow_exit: If `True`, returns an invalid index for points outside the mesh, otherwise keeps the current index.\n\nReturns:\n    index: Index of the neighbor cell or starting cell.\n    leaves_mesh: Whether the walk crossed the mesh boundary. Then `index` is invalid. This is only possible if `allow_exit` is true.\n    is_outside: Whether `location` was outside the cell at index `start_cell_idx`.",
                            "signature": "(self, location: phiml.math._tensors.Tensor, start_cell_idx: phiml.math._tensors.Tensor, allow_exit=False)"
                        },
                        {
                            "name": "closest_vertex",
                            "qualname": "Mesh.closest_vertex",
                            "docstring": "",
                            "signature": "(self, location: phiml.math._tensors.Tensor)"
                        },
                        {
                            "name": "faces_to_vertices",
                            "qualname": "Mesh.faces_to_vertices",
                            "docstring": "",
                            "signature": "(self, values: phiml.math._tensors.Tensor, reduce=<built-in function sum>)"
                        },
                        {
                            "name": "filter_unused_vertices",
                            "qualname": "Mesh.filter_unused_vertices",
                            "docstring": "",
                            "signature": "(self) -> 'Mesh'"
                        },
                        {
                            "name": "get_boundary",
                            "qualname": "Mesh.get_boundary",
                            "docstring": "",
                            "signature": "(self, set_key: str) -> Dict[str, Dict[str, slice]]"
                        },
                        {
                            "name": "get_points",
                            "qualname": "Mesh.get_points",
                            "docstring": "",
                            "signature": "(self, set_key: str) -> phiml.math._tensors.Tensor"
                        },
                        {
                            "name": "lies_inside",
                            "qualname": "Mesh.lies_inside",
                            "docstring": "Tests whether the given location lies inside or outside of the geometry. Locations on the surface count as inside.\n\nWhen dealing with unions or collections of geometries (instance dimensions), a point lies inside the geometry if it lies inside any instance.\n\nArgs:\n  location: float tensor of shape (batch_size, ..., rank)\n\nReturns:\n  bool tensor of shape (*location.shape[:-1], 1).",
                            "signature": "(self, location: phiml.math._tensors.Tensor) -> phiml.math._tensors.Tensor"
                        },
                        {
                            "name": "pad_boundary",
                            "qualname": "Mesh.pad_boundary",
                            "docstring": "",
                            "signature": "(self, value: phiml.math._tensors.Tensor, widths: Dict[str, Dict[str, slice]] = None, mode: phiml.math.extrapolation.Extrapolation = 0, **kwargs) -> phiml.math._tensors.Tensor"
                        },
                        {
                            "name": "rotated",
                            "qualname": "Mesh.rotated",
                            "docstring": "Returns a rotated version of this geometry.\nThe geometry is rotated about its center point.\n\nArgs:\n    angle: Delta rotation.\n        Either\n\n        * Angle(s): scalar angle in 2d or euler angles along `vector` in 3D or higher.\n        * Matrix: d\u2a2fd rotation matrix\n\nReturns:\n    Rotated `Geometry`",
                            "signature": "(self, angle: Union[float, phiml.math._tensors.Tensor]) -> 'Geometry'"
                        },
                        {
                            "name": "sample_uniform",
                            "qualname": "Mesh.sample_uniform",
                            "docstring": "Samples uniformly distributed random points inside this volume.\n\nArgs:\n    *shape: How many points to sample per individual geometry.\n\nReturns:\n    `Tensor` containing all dimensions from `Geometry.shape`, `shape` as well as a `channel` dimension `vector` matching the dimensionality of this `Geometry`.",
                            "signature": "(self, *shape: phiml.math._shape.Shape) -> phiml.math._tensors.Tensor"
                        },
                        {
                            "name": "scaled",
                            "qualname": "Mesh.scaled",
                            "docstring": "Scales each individual geometry by `factor`.\nThe individual `center` points act as pivots for the operation.\n\nArgs:\n    factor:\n\nReturns:",
                            "signature": "(self, factor: Union[float, phiml.math._tensors.Tensor]) -> 'Geometry'"
                        },
                        {
                            "name": "shifted",
                            "qualname": "Mesh.shifted",
                            "docstring": "Returns a translated version of this geometry.\n\nSee Also:\n    `Geometry.at()`.\n\nArgs:\n  delta: direction vector\n  delta: Tensor:\n\nReturns:\n  Geometry: shifted geometry",
                            "signature": "(self, delta: phiml.math._tensors.Tensor) -> 'Mesh'"
                        }
                    ]
                },
                {
                    "name": "Point",
                    "qualname": "Point",
                    "docstring": "Points have zero volume and are determined by a single location.\nAn instance of `Point` represents a single n-dimensional point or a batch of points.",
                    "signature": "(location: phiml.math._tensors.Tensor) -> None",
                    "type": "class",
                    "methods": [
                        {
                            "name": "approximate_signed_distance",
                            "qualname": "Point.approximate_signed_distance",
                            "docstring": "Computes the approximate distance from location to the surface of the geometry.\nLocations outside return positive values, inside negative values and zero exactly at the boundary.\n\nThe exact distance metric used depends on the geometry.\nThe approximation holds close to the surface and the distance grows to infinity as the location is moved infinitely far from the geometry.\nThe distance metric is differentiable and its gradients are bounded at every point in space.\n\nWhen dealing with unions or collections of geometries (instance dimensions), the shortest distance to any instance is returned.\nThis also holds for negative distances.\n\nArgs:\n    location: `Tensor` with one channel dim `vector` matching the geometry's `vector` dim.\n\nReturns:\n    Float `Tensor`",
                            "signature": "(self, location: Union[phiml.math._tensors.Tensor, tuple]) -> phiml.math._tensors.Tensor"
                        },
                        {
                            "name": "at",
                            "qualname": "Point.at",
                            "docstring": "Returns a copy of this `Geometry` with the center at `center`.\nThis is equal to calling `self @ center`.\n\nSee Also:\n    `Geometry.shifted()`.\n\nArgs:\n    center: New center as `Tensor`.\n\nReturns:\n    `Geometry`.",
                            "signature": "(self, center: phiml.math._tensors.Tensor) -> 'Geometry'"
                        },
                        {
                            "name": "bounding_half_extent",
                            "qualname": "Point.bounding_half_extent",
                            "docstring": "The bounding half-extent sets a limit on the outer-most point for each coordinate axis.\nEach component is non-negative.\n\nLet the bounding half-extent have value `e` in dimension `d` (`extent[...,d] = e`).\nThen, no point of the geometry lies further away from its center point than `e` along `d` (in both axis directions).\n\nIf this geometry consists of multiple parts listed along instance/spatial dims, these dims are retained, giving the bounds of each part.\nIf these dims are not present on the result, all parts are assumed to have the same bounds.",
                            "signature": "(self) -> phiml.math._tensors.Tensor"
                        },
                        {
                            "name": "bounding_radius",
                            "qualname": "Point.bounding_radius",
                            "docstring": "Returns the radius of a Sphere object that fully encloses this geometry.\nThe sphere is centered at the center of this geometry.\n\nIf this geometry consists of multiple parts listed along instance/spatial dims, these dims are retained, giving the bounds of each part.\nIf these dims are not present on the result, all parts are assumed to have the same bounds.",
                            "signature": "(self) -> phiml.math._tensors.Tensor"
                        },
                        {
                            "name": "lies_inside",
                            "qualname": "Point.lies_inside",
                            "docstring": "Tests whether the given location lies inside or outside of the geometry. Locations on the surface count as inside.\n\nWhen dealing with unions or collections of geometries (instance dimensions), a point lies inside the geometry if it lies inside any instance.\n\nArgs:\n  location: float tensor of shape (batch_size, ..., rank)\n\nReturns:\n  bool tensor of shape (*location.shape[:-1], 1).",
                            "signature": "(self, location: phiml.math._tensors.Tensor) -> phiml.math._tensors.Tensor"
                        },
                        {
                            "name": "rotated",
                            "qualname": "Point.rotated",
                            "docstring": "Returns a rotated version of this geometry.\nThe geometry is rotated about its center point.\n\nArgs:\n    angle: Delta rotation.\n        Either\n\n        * Angle(s): scalar angle in 2d or euler angles along `vector` in 3D or higher.\n        * Matrix: d\u2a2fd rotation matrix\n\nReturns:\n    Rotated `Geometry`",
                            "signature": "(self, angle) -> 'Geometry'"
                        },
                        {
                            "name": "sample_uniform",
                            "qualname": "Point.sample_uniform",
                            "docstring": "Samples uniformly distributed random points inside this volume.\n\nArgs:\n    *shape: How many points to sample per individual geometry.\n\nReturns:\n    `Tensor` containing all dimensions from `Geometry.shape`, `shape` as well as a `channel` dimension `vector` matching the dimensionality of this `Geometry`.",
                            "signature": "(self, *shape: phiml.math._shape.Shape) -> phiml.math._tensors.Tensor"
                        },
                        {
                            "name": "scaled",
                            "qualname": "Point.scaled",
                            "docstring": "Scales each individual geometry by `factor`.\nThe individual `center` points act as pivots for the operation.\n\nArgs:\n    factor:\n\nReturns:",
                            "signature": "(self, factor: Union[float, phiml.math._tensors.Tensor]) -> 'Geometry'"
                        },
                        {
                            "name": "unstack",
                            "qualname": "Point.unstack",
                            "docstring": "Unstacks this Geometry along the given dimension.\nThe shapes of the returned geometries are reduced by `dimension`.\n\nArgs:\n    dimension: dimension along which to unstack\n\nReturns:\n    geometries: tuple of length equal to `geometry.shape.get_size(dimension)`",
                            "signature": "(self, dimension: str) -> tuple"
                        }
                    ]
                },
                {
                    "name": "SDF",
                    "qualname": "SDF",
                    "docstring": "Function-based signed distance field.\nNegative values lie inside the geometry, the 0-level represents the surface.\n\nArgs:\n    sdf: SDF function. First argument is a `phiml.math.Tensor` with a `vector` channel dim.\n    bounds: Grid limits. The bounds fully enclose all virtual cells.\n    center: (Optional) Geometry center point. Will be computed otherwise.\n    volume: (Optional) Geometry volume. Will be computed otherwise.\n    bounding_radius: (Optional) Geometry bounding radius around center. Will be computed otherwise.",
                    "signature": "(sdf: Callable, out_shape=None, bounds: phi.geom._box.Box = None, center: phiml.math._tensors.Tensor = None, volume: phiml.math._tensors.Tensor = None, bounding_radius: phiml.math._tensors.Tensor = None, sdf_and_grad: Callable = None)",
                    "type": "class",
                    "methods": [
                        {
                            "name": "approximate_closest_surface",
                            "qualname": "SDF.approximate_closest_surface",
                            "docstring": "Find the closest surface face of this geometry given a point that can be outside or inside the geometry.\n\nArgs:\n    location: `Tensor` with a single channel dimension called vector. Can have arbitrary other dimensions.\n\nReturns:\n    signed_distance: Scalar signed distance from `location`  to the closest point on the surface.\n        Positive values indicate the point lies outside the geometry, negative values indicate the point lies inside the geometry.\n    delta: Vector-valued distance vector from `location` to the closest point on the surface.\n    normal: Closest surface normal vector.\n    offset: Min distance of a surface-tangential plane from 0 as a scalar.\n    face_index: (Optional) An index vector pointing at the closest face.",
                            "signature": "(self, location: phiml.math._tensors.Tensor, refine_iter=0) -> Tuple[phiml.math._tensors.Tensor, phiml.math._tensors.Tensor, phiml.math._tensors.Tensor, phiml.math._tensors.Tensor, phiml.math._tensors.Tensor]"
                        },
                        {
                            "name": "approximate_signed_distance",
                            "qualname": "SDF.approximate_signed_distance",
                            "docstring": "Computes the approximate distance from location to the surface of the geometry.\nLocations outside return positive values, inside negative values and zero exactly at the boundary.\n\nThe exact distance metric used depends on the geometry.\nThe approximation holds close to the surface and the distance grows to infinity as the location is moved infinitely far from the geometry.\nThe distance metric is differentiable and its gradients are bounded at every point in space.\n\nWhen dealing with unions or collections of geometries (instance dimensions), the shortest distance to any instance is returned.\nThis also holds for negative distances.\n\nArgs:\n    location: `Tensor` with one channel dim `vector` matching the geometry's `vector` dim.\n\nReturns:\n    Float `Tensor`",
                            "signature": "(self, location: phiml.math._tensors.Tensor) -> phiml.math._tensors.Tensor"
                        },
                        {
                            "name": "at",
                            "qualname": "SDF.at",
                            "docstring": "Returns a copy of this `Geometry` with the center at `center`.\nThis is equal to calling `self @ center`.\n\nSee Also:\n    `Geometry.shifted()`.\n\nArgs:\n    center: New center as `Tensor`.\n\nReturns:\n    `Geometry`.",
                            "signature": "(self, center: phiml.math._tensors.Tensor) -> 'Geometry'"
                        },
                        {
                            "name": "bounding_box",
                            "qualname": "SDF.bounding_box",
                            "docstring": "Returns the approximately smallest axis-aligned box that contains this `Geometry`.\nThe center of the box may not be equal to `self.center`.\n\nReturns:\n    `Box` or `Cuboid` that fully contains this `Geometry`.",
                            "signature": "(self) -> 'Box'"
                        },
                        {
                            "name": "bounding_half_extent",
                            "qualname": "SDF.bounding_half_extent",
                            "docstring": "The bounding half-extent sets a limit on the outer-most point for each coordinate axis.\nEach component is non-negative.\n\nLet the bounding half-extent have value `e` in dimension `d` (`extent[...,d] = e`).\nThen, no point of the geometry lies further away from its center point than `e` along `d` (in both axis directions).\n\nIf this geometry consists of multiple parts listed along instance/spatial dims, these dims are retained, giving the bounds of each part.\nIf these dims are not present on the result, all parts are assumed to have the same bounds.",
                            "signature": "(self) -> phiml.math._tensors.Tensor"
                        },
                        {
                            "name": "bounding_radius",
                            "qualname": "SDF.bounding_radius",
                            "docstring": "Returns the radius of a Sphere object that fully encloses this geometry.\nThe sphere is centered at the center of this geometry.\n\nIf this geometry consists of multiple parts listed along instance/spatial dims, these dims are retained, giving the bounds of each part.\nIf these dims are not present on the result, all parts are assumed to have the same bounds.",
                            "signature": "(self) -> phiml.math._tensors.Tensor"
                        },
                        {
                            "name": "lies_inside",
                            "qualname": "SDF.lies_inside",
                            "docstring": "Tests whether the given location lies inside or outside of the geometry. Locations on the surface count as inside.\n\nWhen dealing with unions or collections of geometries (instance dimensions), a point lies inside the geometry if it lies inside any instance.\n\nArgs:\n  location: float tensor of shape (batch_size, ..., rank)\n\nReturns:\n  bool tensor of shape (*location.shape[:-1], 1).",
                            "signature": "(self, location: phiml.math._tensors.Tensor) -> phiml.math._tensors.Tensor"
                        },
                        {
                            "name": "rotated",
                            "qualname": "SDF.rotated",
                            "docstring": "Returns a rotated version of this geometry.\nThe geometry is rotated about its center point.\n\nArgs:\n    angle: Delta rotation.\n        Either\n\n        * Angle(s): scalar angle in 2d or euler angles along `vector` in 3D or higher.\n        * Matrix: d\u2a2fd rotation matrix\n\nReturns:\n    Rotated `Geometry`",
                            "signature": "(self, angle: Union[float, phiml.math._tensors.Tensor]) -> 'Geometry'"
                        },
                        {
                            "name": "sample_uniform",
                            "qualname": "SDF.sample_uniform",
                            "docstring": "Samples uniformly distributed random points inside this volume.\n\nArgs:\n    *shape: How many points to sample per individual geometry.\n\nReturns:\n    `Tensor` containing all dimensions from `Geometry.shape`, `shape` as well as a `channel` dimension `vector` matching the dimensionality of this `Geometry`.",
                            "signature": "(self, *shape: phiml.math._shape.Shape) -> phiml.math._tensors.Tensor"
                        },
                        {
                            "name": "scaled",
                            "qualname": "SDF.scaled",
                            "docstring": "Scales each individual geometry by `factor`.\nThe individual `center` points act as pivots for the operation.\n\nArgs:\n    factor:\n\nReturns:",
                            "signature": "(self, factor: Union[float, phiml.math._tensors.Tensor]) -> 'Geometry'"
                        },
                        {
                            "name": "sdf_and_gradient",
                            "qualname": "SDF.sdf_and_gradient",
                            "docstring": "",
                            "signature": "(self, location: phiml.math._tensors.Tensor, refine_iter=0) -> Tuple[phiml.math._tensors.Tensor, phiml.math._tensors.Tensor]"
                        },
                        {
                            "name": "shifted",
                            "qualname": "SDF.shifted",
                            "docstring": "Returns a translated version of this geometry.\n\nSee Also:\n    `Geometry.at()`.\n\nArgs:\n  delta: direction vector\n  delta: Tensor:\n\nReturns:\n  Geometry: shifted geometry",
                            "signature": "(self, delta: phiml.math._tensors.Tensor) -> 'Geometry'"
                        }
                    ]
                },
                {
                    "name": "SDFGrid",
                    "qualname": "SDFGrid",
                    "docstring": "Grid-based signed distance field.\n\nArgs:\n    sdf: Signed distance values. `Tensor` with spatial dimensions corresponding to the physical space.\n        Each value samples the SDF value at the center of a virtual cell.\n    bounds: Grid limits. The bounds fully enclose all virtual cells.\n    approximate_outside: Whether queries outside the SDF grid should return approximate values. This requires additional computations.\n    gradient: (Optional) Pre-computed gradient grid. Will be computed otherwise.\n    center: (Optional) Geometry center point. Will be computed otherwise.\n    volume: (Optional) Geometry volume. Will be computed otherwise.\n    bounding_radius: (Optional) Geometry bounding radius around center. Will be computed otherwise.",
                    "signature": "(sdf: phiml.math._tensors.Tensor, bounds: phi.geom._box.Box, approximate_outside=True, gradient: phiml.math._tensors.Tensor = None, to_surface: phiml.math._tensors.Tensor = None, surf_normal: phiml.math._tensors.Tensor = None, surf_index: phiml.math._tensors.Tensor = None, center: phiml.math._tensors.Tensor = None, volume: phiml.math._tensors.Tensor = None, bounding_radius: phiml.math._tensors.Tensor = None)",
                    "type": "class",
                    "methods": [
                        {
                            "name": "approximate_closest_surface",
                            "qualname": "SDFGrid.approximate_closest_surface",
                            "docstring": "Find the closest surface face of this geometry given a point that can be outside or inside the geometry.\n\nArgs:\n    location: `Tensor` with a single channel dimension called vector. Can have arbitrary other dimensions.\n\nReturns:\n    signed_distance: Scalar signed distance from `location`  to the closest point on the surface.\n        Positive values indicate the point lies outside the geometry, negative values indicate the point lies inside the geometry.\n    delta: Vector-valued distance vector from `location` to the closest point on the surface.\n    normal: Closest surface normal vector.\n    offset: Min distance of a surface-tangential plane from 0 as a scalar.\n    face_index: (Optional) An index vector pointing at the closest face.",
                            "signature": "(self, location: phiml.math._tensors.Tensor) -> Tuple[phiml.math._tensors.Tensor, phiml.math._tensors.Tensor, phiml.math._tensors.Tensor, phiml.math._tensors.Tensor, phiml.math._tensors.Tensor]"
                        },
                        {
                            "name": "approximate_fraction_inside",
                            "qualname": "SDFGrid.approximate_fraction_inside",
                            "docstring": "Computes the approximate overlap between the geometry and a small other geometry.\nReturns 1.0 if `other_geometry` is fully enclosed in this geometry and 0.0 if there is no overlap.\nClose to the surface of this geometry, the fraction filled is differentiable w.r.t. the location and size of `other_geometry`.\n\nTo call this method on batches of geometries of same shape, pass a batched Geometry instance.\nThe result tensor will match the batch shape of `other_geometry`.\n\nThe result may only be accurate in special cases.\nThe given geometries may be approximated as spheres or boxes using `bounding_radius()` and `bounding_half_extent()`.\n\nThe default implementation of this method approximates other_geometry as a Sphere and computes the fraction using `approximate_signed_distance()`.\n\nArgs:\n    other_geometry: `Geometry` or geometry batch for which to compute the overlap with `self`.\n    balance: Mid-level between 0 and 1, default 0.5.\n        This value is returned when exactly half of `other_geometry` lies inside `self`.\n        `0.5 < balance <= 1` makes `self` seem larger while `0 <= balance < 0.5`makes `self` seem smaller.\n\nReturns:\n  fraction of cell volume lying inside the geometry. float tensor of shape (other_geometry.batch_shape, 1).",
                            "signature": "(self, other_geometry: 'Geometry', balance: Union[phiml.math._tensors.Tensor, numbers.Number] = 0.5) -> phiml.math._tensors.Tensor"
                        },
                        {
                            "name": "approximate_occupancy",
                            "qualname": "SDFGrid.approximate_occupancy",
                            "docstring": "",
                            "signature": "(self)"
                        },
                        {
                            "name": "approximate_signed_distance",
                            "qualname": "SDFGrid.approximate_signed_distance",
                            "docstring": "Computes the approximate distance from location to the surface of the geometry.\nLocations outside return positive values, inside negative values and zero exactly at the boundary.\n\nThe exact distance metric used depends on the geometry.\nThe approximation holds close to the surface and the distance grows to infinity as the location is moved infinitely far from the geometry.\nThe distance metric is differentiable and its gradients are bounded at every point in space.\n\nWhen dealing with unions or collections of geometries (instance dimensions), the shortest distance to any instance is returned.\nThis also holds for negative distances.\n\nArgs:\n    location: `Tensor` with one channel dim `vector` matching the geometry's `vector` dim.\n\nReturns:\n    Float `Tensor`",
                            "signature": "(self, location: phiml.math._tensors.Tensor) -> phiml.math._tensors.Tensor"
                        },
                        {
                            "name": "at",
                            "qualname": "SDFGrid.at",
                            "docstring": "Returns a copy of this `Geometry` with the center at `center`.\nThis is equal to calling `self @ center`.\n\nSee Also:\n    `Geometry.shifted()`.\n\nArgs:\n    center: New center as `Tensor`.\n\nReturns:\n    `Geometry`.",
                            "signature": "(self, center: phiml.math._tensors.Tensor) -> 'Geometry'"
                        },
                        {
                            "name": "bounding_half_extent",
                            "qualname": "SDFGrid.bounding_half_extent",
                            "docstring": "The bounding half-extent sets a limit on the outer-most point for each coordinate axis.\nEach component is non-negative.\n\nLet the bounding half-extent have value `e` in dimension `d` (`extent[...,d] = e`).\nThen, no point of the geometry lies further away from its center point than `e` along `d` (in both axis directions).\n\nIf this geometry consists of multiple parts listed along instance/spatial dims, these dims are retained, giving the bounds of each part.\nIf these dims are not present on the result, all parts are assumed to have the same bounds.",
                            "signature": "(self) -> phiml.math._tensors.Tensor"
                        },
                        {
                            "name": "bounding_radius",
                            "qualname": "SDFGrid.bounding_radius",
                            "docstring": "Returns the radius of a Sphere object that fully encloses this geometry.\nThe sphere is centered at the center of this geometry.\n\nIf this geometry consists of multiple parts listed along instance/spatial dims, these dims are retained, giving the bounds of each part.\nIf these dims are not present on the result, all parts are assumed to have the same bounds.",
                            "signature": "(self) -> phiml.math._tensors.Tensor"
                        },
                        {
                            "name": "downsample2x",
                            "qualname": "SDFGrid.downsample2x",
                            "docstring": "",
                            "signature": "(self)"
                        },
                        {
                            "name": "lies_inside",
                            "qualname": "SDFGrid.lies_inside",
                            "docstring": "Tests whether the given location lies inside or outside of the geometry. Locations on the surface count as inside.\n\nWhen dealing with unions or collections of geometries (instance dimensions), a point lies inside the geometry if it lies inside any instance.\n\nArgs:\n  location: float tensor of shape (batch_size, ..., rank)\n\nReturns:\n  bool tensor of shape (*location.shape[:-1], 1).",
                            "signature": "(self, location: phiml.math._tensors.Tensor) -> phiml.math._tensors.Tensor"
                        },
                        {
                            "name": "rotated",
                            "qualname": "SDFGrid.rotated",
                            "docstring": "Returns a rotated version of this geometry.\nThe geometry is rotated about its center point.\n\nArgs:\n    angle: Delta rotation.\n        Either\n\n        * Angle(s): scalar angle in 2d or euler angles along `vector` in 3D or higher.\n        * Matrix: d\u2a2fd rotation matrix\n\nReturns:\n    Rotated `Geometry`",
                            "signature": "(self, angle: Union[float, phiml.math._tensors.Tensor]) -> 'Geometry'"
                        },
                        {
                            "name": "sample_uniform",
                            "qualname": "SDFGrid.sample_uniform",
                            "docstring": "Samples uniformly distributed random points inside this volume.\n\nArgs:\n    *shape: How many points to sample per individual geometry.\n\nReturns:\n    `Tensor` containing all dimensions from `Geometry.shape`, `shape` as well as a `channel` dimension `vector` matching the dimensionality of this `Geometry`.",
                            "signature": "(self, *shape: phiml.math._shape.Shape) -> phiml.math._tensors.Tensor"
                        },
                        {
                            "name": "scaled",
                            "qualname": "SDFGrid.scaled",
                            "docstring": "Scales each individual geometry by `factor`.\nThe individual `center` points act as pivots for the operation.\n\nArgs:\n    factor:\n\nReturns:",
                            "signature": "(self, factor: Union[float, phiml.math._tensors.Tensor]) -> 'Geometry'"
                        },
                        {
                            "name": "shifted",
                            "qualname": "SDFGrid.shifted",
                            "docstring": "Returns a translated version of this geometry.\n\nSee Also:\n    `Geometry.at()`.\n\nArgs:\n  delta: direction vector\n  delta: Tensor:\n\nReturns:\n  Geometry: shifted geometry",
                            "signature": "(self, delta: phiml.math._tensors.Tensor) -> 'Geometry'"
                        },
                        {
                            "name": "with_values",
                            "qualname": "SDFGrid.with_values",
                            "docstring": "",
                            "signature": "(self, values: phiml.math._tensors.Tensor)"
                        }
                    ]
                },
                {
                    "name": "Sphere",
                    "qualname": "Sphere",
                    "docstring": "N-dimensional sphere.\nDefined through center position and radius.",
                    "signature": "(center: phiml.math._tensors.Tensor = None, radius: Union[float, phiml.math._tensors.Tensor] = None, volume: Union[float, phiml.math._tensors.Tensor] = None, variable_attrs=('pos', 'radius'), radius_variable=None, pos: phiml.math._tensors.Tensor = None, **center_: Union[float, phiml.math._tensors.Tensor])",
                    "type": "class",
                    "methods": [
                        {
                            "name": "approximate_closest_surface",
                            "qualname": "Sphere.approximate_closest_surface",
                            "docstring": "Find the closest surface face of this geometry given a point that can be outside or inside the geometry.\n\nArgs:\n    location: `Tensor` with a single channel dimension called vector. Can have arbitrary other dimensions.\n\nReturns:\n    signed_distance: Scalar signed distance from `location`  to the closest point on the surface.\n        Positive values indicate the point lies outside the geometry, negative values indicate the point lies inside the geometry.\n    delta: Vector-valued distance vector from `location` to the closest point on the surface.\n    normal: Closest surface normal vector.\n    offset: Min distance of a surface-tangential plane from 0 as a scalar.\n    face_index: (Optional) An index vector pointing at the closest face.",
                            "signature": "(self, location: phiml.math._tensors.Tensor) -> Tuple[phiml.math._tensors.Tensor, phiml.math._tensors.Tensor, phiml.math._tensors.Tensor, phiml.math._tensors.Tensor, phiml.math._tensors.Tensor]"
                        },
                        {
                            "name": "approximate_signed_distance",
                            "qualname": "Sphere.approximate_signed_distance",
                            "docstring": "Computes the exact distance from location to the closest point on the sphere.\nVery close to the sphere center, the distance takes a constant value.\n\nArgs:\n  location: float tensor of shape (batch_size, ..., rank)\n\nReturns:\n  float tensor of shape (*location.shape[:-1], 1).",
                            "signature": "(self, location: Union[phiml.math._tensors.Tensor, tuple])"
                        },
                        {
                            "name": "at",
                            "qualname": "Sphere.at",
                            "docstring": "Returns a copy of this `Geometry` with the center at `center`.\nThis is equal to calling `self @ center`.\n\nSee Also:\n    `Geometry.shifted()`.\n\nArgs:\n    center: New center as `Tensor`.\n\nReturns:\n    `Geometry`.",
                            "signature": "(self, center: phiml.math._tensors.Tensor) -> 'Geometry'"
                        },
                        {
                            "name": "bounding_half_extent",
                            "qualname": "Sphere.bounding_half_extent",
                            "docstring": "The bounding half-extent sets a limit on the outer-most point for each coordinate axis.\nEach component is non-negative.\n\nLet the bounding half-extent have value `e` in dimension `d` (`extent[...,d] = e`).\nThen, no point of the geometry lies further away from its center point than `e` along `d` (in both axis directions).\n\nIf this geometry consists of multiple parts listed along instance/spatial dims, these dims are retained, giving the bounds of each part.\nIf these dims are not present on the result, all parts are assumed to have the same bounds.",
                            "signature": "(self)"
                        },
                        {
                            "name": "bounding_radius",
                            "qualname": "Sphere.bounding_radius",
                            "docstring": "Returns the radius of a Sphere object that fully encloses this geometry.\nThe sphere is centered at the center of this geometry.\n\nIf this geometry consists of multiple parts listed along instance/spatial dims, these dims are retained, giving the bounds of each part.\nIf these dims are not present on the result, all parts are assumed to have the same bounds.",
                            "signature": "(self)"
                        },
                        {
                            "name": "lies_inside",
                            "qualname": "Sphere.lies_inside",
                            "docstring": "Tests whether the given location lies inside or outside of the geometry. Locations on the surface count as inside.\n\nWhen dealing with unions or collections of geometries (instance dimensions), a point lies inside the geometry if it lies inside any instance.\n\nArgs:\n  location: float tensor of shape (batch_size, ..., rank)\n\nReturns:\n  bool tensor of shape (*location.shape[:-1], 1).",
                            "signature": "(self, location)"
                        },
                        {
                            "name": "rotated",
                            "qualname": "Sphere.rotated",
                            "docstring": "Returns a rotated version of this geometry.\nThe geometry is rotated about its center point.\n\nArgs:\n    angle: Delta rotation.\n        Either\n\n        * Angle(s): scalar angle in 2d or euler angles along `vector` in 3D or higher.\n        * Matrix: d\u2a2fd rotation matrix\n\nReturns:\n    Rotated `Geometry`",
                            "signature": "(self, angle)"
                        },
                        {
                            "name": "sample_uniform",
                            "qualname": "Sphere.sample_uniform",
                            "docstring": "Samples uniformly distributed random points inside this volume.\n\nArgs:\n    *shape: How many points to sample per individual geometry.\n\nReturns:\n    `Tensor` containing all dimensions from `Geometry.shape`, `shape` as well as a `channel` dimension `vector` matching the dimensionality of this `Geometry`.",
                            "signature": "(self, *shape: phiml.math._shape.Shape)"
                        },
                        {
                            "name": "scaled",
                            "qualname": "Sphere.scaled",
                            "docstring": "Scales each individual geometry by `factor`.\nThe individual `center` points act as pivots for the operation.\n\nArgs:\n    factor:\n\nReturns:",
                            "signature": "(self, factor: Union[float, phiml.math._tensors.Tensor]) -> 'Geometry'"
                        }
                    ]
                },
                {
                    "name": "UniformGrid",
                    "qualname": "UniformGrid",
                    "docstring": "An instance of UniformGrid represents all cells of a regular grid as a batch of boxes.",
                    "signature": "(resolution: phiml.math._shape.Shape = None, bounds: phi.geom._box.Box = None, **resolution_)",
                    "type": "class",
                    "methods": [
                        {
                            "name": "bounding_half_extent",
                            "qualname": "UniformGrid.bounding_half_extent",
                            "docstring": "The bounding half-extent sets a limit on the outer-most point for each coordinate axis.\nEach component is non-negative.\n\nLet the bounding half-extent have value `e` in dimension `d` (`extent[...,d] = e`).\nThen, no point of the geometry lies further away from its center point than `e` along `d` (in both axis directions).\n\nIf this geometry consists of multiple parts listed along instance/spatial dims, these dims are retained, giving the bounds of each part.\nIf these dims are not present on the result, all parts are assumed to have the same bounds.",
                            "signature": "(self) -> phiml.math._tensors.Tensor"
                        },
                        {
                            "name": "bounding_radius",
                            "qualname": "UniformGrid.bounding_radius",
                            "docstring": "Returns the radius of a Sphere object that fully encloses this geometry.\nThe sphere is centered at the center of this geometry.\n\nIf this geometry consists of multiple parts listed along instance/spatial dims, these dims are retained, giving the bounds of each part.\nIf these dims are not present on the result, all parts are assumed to have the same bounds.",
                            "signature": "(self) -> phiml.math._tensors.Tensor"
                        },
                        {
                            "name": "box",
                            "qualname": "UniformGrid.corner_representation",
                            "docstring": "",
                            "signature": "(self) -> 'Box'"
                        },
                        {
                            "name": "center_representation",
                            "qualname": "UniformGrid.center_representation",
                            "docstring": "",
                            "signature": "(self, size_variable=True) -> 'Cuboid'"
                        },
                        {
                            "name": "corner_representation",
                            "qualname": "UniformGrid.corner_representation",
                            "docstring": "",
                            "signature": "(self) -> 'Box'"
                        },
                        {
                            "name": "cuboid",
                            "qualname": "UniformGrid.center_representation",
                            "docstring": "",
                            "signature": "(self, size_variable=True) -> 'Cuboid'"
                        },
                        {
                            "name": "interior",
                            "qualname": "UniformGrid.interior",
                            "docstring": "",
                            "signature": "(self) -> 'Geometry'"
                        },
                        {
                            "name": "list_cells",
                            "qualname": "UniformGrid.list_cells",
                            "docstring": "",
                            "signature": "(self, dim_name)"
                        },
                        {
                            "name": "padded",
                            "qualname": "UniformGrid.padded",
                            "docstring": "",
                            "signature": "(self, widths: dict)"
                        },
                        {
                            "name": "position_of",
                            "qualname": "UniformGrid.position_of",
                            "docstring": "",
                            "signature": "(self, voxel_index: phiml.math._tensors.Tensor)"
                        },
                        {
                            "name": "rotated",
                            "qualname": "UniformGrid.rotated",
                            "docstring": "Returns a rotated version of this geometry.\nThe geometry is rotated about its center point.\n\nArgs:\n    angle: Delta rotation.\n        Either\n\n        * Angle(s): scalar angle in 2d or euler angles along `vector` in 3D or higher.\n        * Matrix: d\u2a2fd rotation matrix\n\nReturns:\n    Rotated `Geometry`",
                            "signature": "(self, angle) -> phi.geom._geom.Geometry"
                        },
                        {
                            "name": "shallow_equals",
                            "qualname": "UniformGrid.shallow_equals",
                            "docstring": "Quick equality check.\nMay return `False` even if `other == self`.\nHowever, if `True` is returned, the geometries are guaranteed to be equal.\n\nThe `shallow_equals()` check does not compare all tensor elements but merely checks whether the same tensors are referenced.",
                            "signature": "(self, other)"
                        },
                        {
                            "name": "shifted",
                            "qualname": "UniformGrid.shifted",
                            "docstring": "Returns a translated version of this geometry.\n\nSee Also:\n    `Geometry.at()`.\n\nArgs:\n  delta: direction vector\n  delta: Tensor:\n\nReturns:\n  Geometry: shifted geometry",
                            "signature": "(self, delta: phiml.math._tensors.Tensor, **delta_by_dim)"
                        },
                        {
                            "name": "stagger",
                            "qualname": "UniformGrid.stagger",
                            "docstring": "",
                            "signature": "(self, dim: str, lower: bool, upper: bool)"
                        },
                        {
                            "name": "staggered_cells",
                            "qualname": "UniformGrid.staggered_cells",
                            "docstring": "",
                            "signature": "(self, boundaries: phiml.math.extrapolation.Extrapolation) -> Dict[str, ForwardRef('UniformGrid')]"
                        },
                        {
                            "name": "voxel_at",
                            "qualname": "UniformGrid.voxel_at",
                            "docstring": "",
                            "signature": "(self, location: phiml.math._tensors.Tensor, clamp=True)"
                        },
                        {
                            "name": "with_scaled_resolution",
                            "qualname": "UniformGrid.with_scaled_resolution",
                            "docstring": "",
                            "signature": "(self, scale: float)"
                        }
                    ]
                }
            ],
            "submodules": []
        },
        {
            "type": "module",
            "name": "math",
            "docstring": "Alias for [`phiml.math`](https://tum-pbs.github.io/PhiML/phiml/math/index.html).\n\n\u03a6-Flow builds on the tensor functionality from [\u03a6-ML](https://github.com/tum-pbs/PhiML).\nIts `math` package is re-imported here for convenience.",
            "functions": [],
            "classes": [],
            "submodules": [
                {
                    "type": "module",
                    "name": "phi.math.backend",
                    "docstring": "Alias for [`phiml.backend`](https://tum-pbs.github.io/PhiML/phiml/backend/index.html).",
                    "functions": [],
                    "classes": [],
                    "submodules": []
                },
                {
                    "type": "module",
                    "name": "phi.math.extrapolation",
                    "docstring": "Alias for [`phiml.math.extrapolation`](https://tum-pbs.github.io/PhiML/phiml/math/extrapolation.html).",
                    "functions": [],
                    "classes": [],
                    "submodules": []
                },
                {
                    "type": "module",
                    "name": "phi.math.magic",
                    "docstring": "Alias for [`phiml.math.magic`](https://tum-pbs.github.io/PhiML/phiml/math/magic.html).",
                    "functions": [],
                    "classes": [],
                    "submodules": []
                }
            ]
        },
        {
            "type": "module",
            "name": "physics",
            "docstring": "Contains built-in physics functions, mainly for partial differential equations, such as incompressible fluids.\nThe actual physics functions are located in the submodules of `phi.physics`.\n\nSome physics functions have built-in time advancement while others return the PDE term, i.e. the derivative.\nThe time-advancing functions always take a time increment argument called `dt`.\n\nSee the `phi.physics` module documentation at https://tum-pbs.github.io/PhiFlow/Physics.html",
            "functions": [],
            "classes": [],
            "submodules": [
                {
                    "type": "module",
                    "name": "phi.physics.advect",
                    "docstring": "Container for different advection schemes for grids and particles.\n\nExamples:\n\n* semi_lagrangian (grid)\n* mac_cormack (grid)\n* runge_kutta_4 (particle)",
                    "functions": [
                        {
                            "name": "advect",
                            "qualname": "advect",
                            "docstring": "Advect `field` along the `velocity` vectors using the specified integrator.\n\nThe behavior depends on the type of `field`:\n\n* `phi.field.PointCloud`: Points are advected forward, see `points`.\n* `phi.field.Grid`: Sample points are traced backward, see `semi_lagrangian`.\n\nArgs:\n    field: Field to be advected as `phi.field.Field`.\n    velocity: Any `phi.field.Field` that can be sampled in the elements of `field`.\n    dt: Time increment\n    integrator: ODE integrator for solving the movement.\n\nReturns:\n    Advected field of same type as `field`",
                            "signature": "(field: phi.field._field.Field, velocity: phi.field._field.Field, dt: float, integrator=<function euler at 0x000001ED3A573BA0>) -> phi.field._field.Field"
                        },
                        {
                            "name": "differential",
                            "qualname": "differential",
                            "docstring": "Computes the differential advection term using the differentiation Scheme indicated by `order`, \u00b4implicit\u00b4 and `upwind`.\n\nFor a velocity field u, the advection term as it appears on the right-hand-side of a PDE is -u\u00b7\u2207u, including the negative sign.\n\nFor unstructured meshes, computes -1/V \u2211_f (n\u00b7u_prev) u \u03c1 A\n\nArgs:\n    u: Scalar or vector-valued `Field` sampled on a `CenteredGrid`, `StaggeredGrid` or `Mesh`.\n    velocity: `Field` that can be sampled at the elements of `u`.\n        For FVM, the advection term is typically linearized by setting `velocity = previous_velocity`.\n        Passing `velocity=u` yields non-linear terms which cannot be traced inside linear functions.\n    order: Spatial order of accuracy.\n        Higher orders entail larger stencils and more computation time but result in more accurate results assuming a large enough resolution.\n        Supported for grids: 2 explicit, 4 explicit, 6 implicit (inherited from `phi.field.spatial_gradient()` and resampling).\n        Passing order=4 currently uses 2nd-order resampling. This is work-in-progress.\n        For FVM, the order is used when interpolating centroid values to faces if needed.\n    implicit: When a `Solve` object is passed, performs an implicit operation with the specified solver and tolerances.\n        Otherwise, an explicit stencil is used.\n    upwind: Whether to use upwind interpolation. Only supported for FVM at the moment.\n\nReturns:\n    Differential convection term as `Field` on the same geometry.",
                            "signature": "(u: phi.field._field.Field, velocity: phi.field._field.Field, density: float = 1.0, order=2, implicit: phiml.math._optimize.Solve = None, upwind=True) -> phi.field._field.Field"
                        },
                        {
                            "name": "euler",
                            "qualname": "euler",
                            "docstring": "Euler integrator.",
                            "signature": "(data: phi.field._field.Field, velocity: phi.field._field.Field, dt: float, v0: phiml.math._tensors.Tensor = None) -> phiml.math._tensors.Tensor"
                        },
                        {
                            "name": "finite_difference",
                            "qualname": "differential",
                            "docstring": "Computes the differential advection term using the differentiation Scheme indicated by `order`, \u00b4implicit\u00b4 and `upwind`.\n\nFor a velocity field u, the advection term as it appears on the right-hand-side of a PDE is -u\u00b7\u2207u, including the negative sign.\n\nFor unstructured meshes, computes -1/V \u2211_f (n\u00b7u_prev) u \u03c1 A\n\nArgs:\n    u: Scalar or vector-valued `Field` sampled on a `CenteredGrid`, `StaggeredGrid` or `Mesh`.\n    velocity: `Field` that can be sampled at the elements of `u`.\n        For FVM, the advection term is typically linearized by setting `velocity = previous_velocity`.\n        Passing `velocity=u` yields non-linear terms which cannot be traced inside linear functions.\n    order: Spatial order of accuracy.\n        Higher orders entail larger stencils and more computation time but result in more accurate results assuming a large enough resolution.\n        Supported for grids: 2 explicit, 4 explicit, 6 implicit (inherited from `phi.field.spatial_gradient()` and resampling).\n        Passing order=4 currently uses 2nd-order resampling. This is work-in-progress.\n        For FVM, the order is used when interpolating centroid values to faces if needed.\n    implicit: When a `Solve` object is passed, performs an implicit operation with the specified solver and tolerances.\n        Otherwise, an explicit stencil is used.\n    upwind: Whether to use upwind interpolation. Only supported for FVM at the moment.\n\nReturns:\n    Differential convection term as `Field` on the same geometry.",
                            "signature": "(u: phi.field._field.Field, velocity: phi.field._field.Field, density: float = 1.0, order=2, implicit: phiml.math._optimize.Solve = None, upwind=True) -> phi.field._field.Field"
                        },
                        {
                            "name": "finite_rk4",
                            "qualname": "finite_rk4",
                            "docstring": "Runge-Kutta-4 integrator with Euler fallback where velocity values are NaN.",
                            "signature": "(data: phi.field._field.Field, velocity: phi.field._field.Field, dt: float, v0: phiml.math._tensors.Tensor = None) -> phiml.math._tensors.Tensor"
                        },
                        {
                            "name": "mac_cormack",
                            "qualname": "mac_cormack",
                            "docstring": "MacCormack advection uses a forward and backward lookup to determine the first-order error of semi-Lagrangian advection.\nIt then uses that error estimate to correct the field values.\nTo avoid overshoots, the resulting value is bounded by the neighbouring grid cells of the backward lookup.\n\nArgs:\n    field: Field to be advected, one of `(CenteredGrid, StaggeredGrid)`\n    velocity: Vector field, need not be sampled at same locations as `field`.\n    dt: Time increment\n    correction_strength: The estimated error is multiplied by this factor before being applied.\n        The case correction_strength=0 equals semi-lagrangian advection. Set lower than 1.0 to avoid oscillations.\n    integrator: ODE integrator for solving the movement.\n\nReturns:\n    Advected field of type `type(field)`",
                            "signature": "(field: phi.field._field.Field, velocity: phi.field._field.Field, dt: float, correction_strength=1.0, integrator=<function euler at 0x000001ED3A573BA0>) -> phi.field._field.Field"
                        },
                        {
                            "name": "points",
                            "qualname": "points",
                            "docstring": "Advects the sample points of a point cloud using a simple Euler step.\nEach point moves by an amount equal to the local velocity times `dt`.\n\nArgs:\n    points: Points to be advected. Can be provided as position `Tensor`, `Geometry` or `Field`.\n    velocity: velocity sampled at the same points as the point cloud\n    dt: Euler step time increment\n    integrator: ODE integrator for solving the movement.\n\nReturns:\n    Advected points, same type as `points`.",
                            "signature": "(points: Union[phi.field._field.Field, phi.geom._geom.Geometry, phiml.math._tensors.Tensor], velocity: phi.field._field.Field, dt: float, integrator=<function euler at 0x000001ED3A573BA0>)"
                        },
                        {
                            "name": "rk4",
                            "qualname": "rk4",
                            "docstring": "Runge-Kutta-4 integrator.",
                            "signature": "(data: phi.field._field.Field, velocity: phi.field._field.Field, dt: float, v0: phiml.math._tensors.Tensor = None) -> phiml.math._tensors.Tensor"
                        },
                        {
                            "name": "semi_lagrangian",
                            "qualname": "semi_lagrangian",
                            "docstring": "Semi-Lagrangian advection with simple backward lookup.\n\nThis method samples the `velocity` at the grid points of `field`\nto determine the lookup location for each grid point by walking backwards along the velocity vectors.\nThe new values are then determined by sampling `field` at these lookup locations.\n\nArgs:\n    field: quantity to be advected, stored on a grid (CenteredGrid or StaggeredGrid)\n    velocity: vector field, need not be compatible with with `field`.\n    dt: time increment\n    integrator: ODE integrator for solving the movement.\n\nReturns:\n    Field with same sample points as `field`",
                            "signature": "(field: phi.field._field.Field, velocity: phi.field._field.Field, dt: float, integrator=<function euler at 0x000001ED3A573BA0>) -> phi.field._field.Field"
                        }
                    ],
                    "classes": [],
                    "submodules": []
                },
                {
                    "type": "module",
                    "name": "phi.physics.diffuse",
                    "docstring": "Functions to simulate diffusion processes on `phi.field.Field` objects.",
                    "functions": [
                        {
                            "name": "differential",
                            "qualname": "differential",
                            "docstring": "Compute the differential diffusion term, d\u00b7\u2207\u00b2u.\nFor grids, uses a finite difference scheme specified by `order` and `implicit`.\nFor FVM, the scheme is specified via `order` and `upwind`.\n\nIn contrast to `explicit` and `implicit`, accuracy can be increased by using stencils of higher-order rather than calculating sub-steps.\n\nArgs:\n    u: Scalar or vector-valued `Field` sampled on a `CenteredGrid`, `StaggeredGrid` or centered `Mesh`.\n    diffusivity: Dynamic viscosity, i.e. diffusion per time. Constant or varying by cell.\n    gradient: Only used by FVM at the moment. Approximate gradient of `u`, e.g. \u2207u of the previous time step.\n        If `None`, approximates the gradient as `(u_neighbor - u_self) / distance`.\n    order: Spatial order of accuracy.\n        Higher orders entail larger stencils and more computation time but result in more accurate results assuming a large enough resolution.\n        Supported: 2 explicit, 4 explicit, 6 implicit (inherited from `phi.field.laplace()`).\n        For FVM, the order is used when interpolating `v` and `prev_v` to cell faces if needed.\n    implicit: When a `Solve` object is passed, performs an implicit operation with the specified solver and tolerances.\n        Otherwise, an explicit stencil is used.\n    upwind: For unstructured meshes only. Whether to use upwind interpolation.\n    correct_skew: If `True`, adds a correction term for cell skewness. This requires `gradient` to be passed.\n\nReturns:\n    Differential diffusion as a `Field` on the same geometry.",
                            "signature": "(u: phi.field._field.Field, diffusivity: Union[float, phiml.math._tensors.Tensor, phi.field._field.Field], gradient: phi.field._field.Field = None, order: int = 2, implicit: phiml.math._optimize.Solve = None, upwind: phi.field._field.Field = None, correct_skew=True) -> phi.field._field.Field"
                        },
                        {
                            "name": "explicit",
                            "qualname": "explicit",
                            "docstring": "Explicit Euler diffusion with substeps.\n\nSimulate a finite-time diffusion process of the form dF/dt = \u03b1 \u00b7 \u0394F on a given `Field` Field with diffusion coefficient \u03b1.\n\nArgs:\n    u: CenteredGrid, StaggeredGrid or ConstantField\n    diffusivity: Diffusion per time. `diffusion_amount = diffusivity * dt`\n        Can be a number, `phi.Tensor` or `phi.field.Field`.\n        If a channel dimension is present, it will be interpreted as non-isotropic diffusion.\n    dt: Time interval. `diffusion_amount = diffusivity * dt`\n    substeps: number of iterations to use (Default value = 1)\n    order: Spatial order of accuracy.\n        Higher orders entail larger stencils and more computation time but result in more accurate results assuming a large enough resolution.\n        Supported: 2 explicit, 4 explicit, 6 implicit (inherited from `phi.field.laplace()`).\n        For FVM, the order is used when interpolating `v` and `prev_v` to cell faces if needed.\n    implicit: When a `Solve` object is passed, performs a spatially implicit operation with the specified solver and tolerances.\n        Otherwise, an explicit stencil is used.\n    gradient: Only used by FVM at the moment. Approximate gradient of `u`, e.g. \u2207u of the previous time step.\n        If `None`, approximates the gradient as `(u_neighbor - u_self) / distance`.\n    upwind: For unstructured meshes only. Whether to use upwind interpolation.\n    correct_skew: If `True`, adds a correction term for cell skewness. This requires `gradient` to be passed.\n\nReturns:\n    Diffused field of same type as `field`.",
                            "signature": "(u: phi.field._field.Field, diffusivity: Union[float, phiml.math._tensors.Tensor, phi.field._field.Field], dt: Union[float, phiml.math._tensors.Tensor], substeps: int = 1, order: int = 2, implicit: phiml.math._optimize.Solve = None, gradient: phi.field._field.Field = None, upwind: phi.field._field.Field = None, correct_skew=True) -> phi.field._field.Field"
                        },
                        {
                            "name": "finite_difference",
                            "qualname": "differential",
                            "docstring": "Compute the differential diffusion term, d\u00b7\u2207\u00b2u.\nFor grids, uses a finite difference scheme specified by `order` and `implicit`.\nFor FVM, the scheme is specified via `order` and `upwind`.\n\nIn contrast to `explicit` and `implicit`, accuracy can be increased by using stencils of higher-order rather than calculating sub-steps.\n\nArgs:\n    u: Scalar or vector-valued `Field` sampled on a `CenteredGrid`, `StaggeredGrid` or centered `Mesh`.\n    diffusivity: Dynamic viscosity, i.e. diffusion per time. Constant or varying by cell.\n    gradient: Only used by FVM at the moment. Approximate gradient of `u`, e.g. \u2207u of the previous time step.\n        If `None`, approximates the gradient as `(u_neighbor - u_self) / distance`.\n    order: Spatial order of accuracy.\n        Higher orders entail larger stencils and more computation time but result in more accurate results assuming a large enough resolution.\n        Supported: 2 explicit, 4 explicit, 6 implicit (inherited from `phi.field.laplace()`).\n        For FVM, the order is used when interpolating `v` and `prev_v` to cell faces if needed.\n    implicit: When a `Solve` object is passed, performs an implicit operation with the specified solver and tolerances.\n        Otherwise, an explicit stencil is used.\n    upwind: For unstructured meshes only. Whether to use upwind interpolation.\n    correct_skew: If `True`, adds a correction term for cell skewness. This requires `gradient` to be passed.\n\nReturns:\n    Differential diffusion as a `Field` on the same geometry.",
                            "signature": "(u: phi.field._field.Field, diffusivity: Union[float, phiml.math._tensors.Tensor, phi.field._field.Field], gradient: phi.field._field.Field = None, order: int = 2, implicit: phiml.math._optimize.Solve = None, upwind: phi.field._field.Field = None, correct_skew=True) -> phi.field._field.Field"
                        },
                        {
                            "name": "fourier",
                            "qualname": "fourier",
                            "docstring": "Exact diffusion of a periodic field in frequency space.\n\nFor non-periodic fields or non-constant diffusivity, use another diffusion function such as `explicit()`.\n\nArgs:\n    field:\n    diffusivity: Diffusion per time. `diffusion_amount = diffusivity * dt`\n    dt: Time interval. `diffusion_amount = diffusivity * dt`\n\nReturns:\n    Diffused field of same type as `field`.",
                            "signature": "(field: phi.field._field.Field, diffusivity: Union[float, phiml.math._tensors.Tensor], dt: Union[float, phiml.math._tensors.Tensor]) -> phi.field._field.Field"
                        },
                        {
                            "name": "implicit",
                            "qualname": "implicit",
                            "docstring": "Implicit Euler diffusion.\n\nDiffusion by solving a linear system of equations.\n\nArgs:\n    field: `phi.field.Field` to diffuse.\n    diffusivity: Diffusion per time. `diffusion_amount = diffusivity * dt`\n    dt: Time interval. `diffusion_amount = diffusivity * dt`\n    solve: Implicit solve parameters.\n    gradient: Only used by FVM at the moment. Approximate gradient of `u`, e.g. \u2207u of the previous time step.\n        If `None`, approximates the gradient as `(u_neighbor - u_self) / distance`.\n    upwind: For unstructured meshes only. Whether to use upwind interpolation.\n    correct_skew: If `True`, adds a correction term for cell skewness. This requires `gradient` to be passed.\n    gradient_for_diffusivity: Whether to compute the gradient w.r.t. the diffusivity parameters.\n\nReturns:\n    Diffused field of same type as `field`.",
                            "signature": "(field: phi.field._field.Field, diffusivity: Union[float, phiml.math._tensors.Tensor, phi.field._field.Field], dt: Union[float, phiml.math._tensors.Tensor], solve=CG with tolerance None (rel), None (abs), max_iterations=1000, gradient: phi.field._field.Field = None, upwind: phi.field._field.Field = None, correct_skew=True, gradient_for_diffusivity=True) -> phi.field._field.Field"
                        }
                    ],
                    "classes": [],
                    "submodules": []
                },
                {
                    "type": "module",
                    "name": "phi.physics.fluid",
                    "docstring": "Functions for simulating incompressible fluids, both grid-based and particle-based.\n\nThe main function for incompressible fluids (Eulerian as well as FLIP / PIC) is `make_incompressible()` which removes the divergence of a velocity field.",
                    "functions": [
                        {
                            "name": "apply_boundary_conditions",
                            "qualname": "apply_boundary_conditions",
                            "docstring": "Enforces velocities boundary conditions on a velocity grid.\nCells inside obstacles will get their velocity from the obstacle movement.\nCells outside far away will be unaffected.\n\nArgs:\n  velocity: Velocity `Grid`.\n    obstacles: `Obstacle` or `phi.geom.Geometry` or tuple/list thereof to specify boundary conditions inside the domain.\n\nReturns:\n    Velocity of same type as `velocity`",
                            "signature": "(velocity: phi.field._field.Field, obstacles: phi.physics.fluid.Obstacle)"
                        },
                        {
                            "name": "boundary_push",
                            "qualname": "boundary_push",
                            "docstring": "Enforces boundary conditions by correcting possible errors of the advection step and shifting particles out of\nobstacles or back into the domain.\n\nArgs:\n    particles: PointCloud holding particle positions as elements\n    obstacles: List of `Obstacle` or `Geometry` objects where any particles inside should get shifted outwards\n    separation: Minimum distance between particles and domain boundary / obstacle surface after particles have been shifted.\n\nReturns:\n    PointCloud where all particles are inside the domain / outside of obstacles.",
                            "signature": "(particles: <function PointCloud at 0x000001ED090C9BC0>, obstacles: tuple, separation: float = 0.5) -> <function PointCloud at 0x000001ED090C9BC0>"
                        },
                        {
                            "name": "incompressible_rk4",
                            "qualname": "incompressible_rk4",
                            "docstring": "Implements the 4th-order Runge-Kutta time advancement scheme for incompressible vector fields.\nThis approach is inspired by [Kampanis et. al., 2006](https://www.sciencedirect.com/science/article/pii/S0021999105005061) and incorporates the pressure treatment into the time step.\n\nArgs:\n    pde: Momentum equation. Function that computes all PDE terms not related to pressure, e.g. diffusion, advection, external forces.\n    velocity: Velocity grid at time `t`.\n    pressure: Pressure at time `t`.\n    dt: Time increment to integrate.\n    pressure_order: spatial order for derivative computations.\n        For Higher-order schemes, the laplace operation is not conducted with a stencil exactly corresponding to the one used in divergence calculations but a smaller one instead.\n        While this disrupts the formal correctness of the method it only induces insignificant errors and yields considerable performance gains.\n        supported: explicit 2/4th order - implicit 6th order (obstacles are only supported with explicit 2nd order)\n    pressure_solve: `Solve` object specifying method and tolerances for the implicit pressure solve.\n    **pde_aux_kwargs: Auxiliary arguments for `pde`. These are considered constant over time.\n\nReturns:\n    velocity: Velocity at time `t+dt`, same type as `velocity`.\n    pressure: Pressure grid at time `t+dt`, `CenteredGrid`.",
                            "signature": "(pde: Callable, velocity: phi.field._field.Field, pressure: phi.field._field.Field, dt, pressure_order=4, pressure_solve=CG with tolerance None (rel), None (abs), max_iterations=1000, **pde_aux_kwargs)"
                        },
                        {
                            "name": "make_incompressible",
                            "qualname": "make_incompressible",
                            "docstring": "Projects the given velocity field by solving for the pressure and subtracting its spatial_gradient.\n\nThis method is similar to :func:`field.divergence_free()` but differs in how the boundary conditions are specified.\n\nArgs:\n    velocity: Vector field sampled on a grid.\n    obstacles: `Obstacle` or `phi.geom.Geometry` or tuple/list thereof to specify boundary conditions inside the domain.\n    solve: `Solve` object specifying method and tolerances for the implicit pressure solve.\n    active: (Optional) Mask for which cells the pressure should be solved.\n        If given, the velocity may take `NaN` values where it does not contribute to the pressure.\n        Also, the total divergence will never be subtracted if active is given, even if all values are 1.\n    order: spatial order for derivative computations.\n        For Higher-order schemes, the laplace operation is not conducted with a stencil exactly corresponding to the one used in divergence calculations but a smaller one instead.\n        While this disrupts the formal correctness of the method it only induces insignificant errors and yields considerable performance gains.\n        supported: explicit 2/4th order - implicit 6th order (obstacles are only supported with explicit 2nd order)\n\nReturns:\n    velocity: divergence-free velocity of type `type(velocity)`\n    pressure: solved pressure field, `CenteredGrid`",
                            "signature": "(velocity: phi.field._field.Field, obstacles: phi.physics.fluid.Obstacle = (), solve: phiml.math._optimize.Solve = auto with tolerance None (rel), None (abs), max_iterations=1000, active: <function CenteredGrid at 0x000001ED090C85E0> = None, order: int = 2, correct_skew=False, wide_stencil: bool = None) -> Tuple[phi.field._field.Field, phi.field._field.Field]"
                        }
                    ],
                    "classes": [
                        {
                            "name": "Obstacle",
                            "qualname": "Obstacle",
                            "docstring": "An obstacle defines boundary conditions inside a geometry.\nIt can also have a linear and angular velocity.\n\nArgs:\n    geometry: Physical shape and size of the obstacle.\n    velocity: Linear velocity vector of the obstacle.\n    angular_velocity: Rotation speed of the obstacle. Scalar value in 2D, vector in 3D.",
                            "signature": "(geometry, velocity=0, angular_velocity=0)",
                            "type": "class",
                            "methods": [
                                {
                                    "name": "at",
                                    "qualname": "Obstacle.at",
                                    "docstring": "",
                                    "signature": "(self, position: phiml.math._tensors.Tensor)"
                                },
                                {
                                    "name": "copied_with",
                                    "qualname": "Obstacle.copied_with",
                                    "docstring": "",
                                    "signature": "(self, **kwargs)"
                                },
                                {
                                    "name": "rotated",
                                    "qualname": "Obstacle.rotated",
                                    "docstring": "",
                                    "signature": "(self, angle: Union[float, phiml.math._tensors.Tensor])"
                                },
                                {
                                    "name": "shifted",
                                    "qualname": "Obstacle.shifted",
                                    "docstring": "",
                                    "signature": "(self, delta: phiml.math._tensors.Tensor)"
                                },
                                {
                                    "name": "with_geometry",
                                    "qualname": "Obstacle.with_geometry",
                                    "docstring": "",
                                    "signature": "(self, geometry)"
                                }
                            ]
                        }
                    ],
                    "submodules": []
                },
                {
                    "type": "module",
                    "name": "phi.physics.integrate",
                    "docstring": "",
                    "functions": [
                        {
                            "name": "euler",
                            "qualname": "euler",
                            "docstring": "",
                            "signature": "(pde: Callable, *state, dt=1.0, **pde_aux_kwargs)"
                        },
                        {
                            "name": "rk4",
                            "qualname": "rk4",
                            "docstring": "",
                            "signature": "(pde: Callable, *state, dt=1.0, **pde_aux_kwargs)"
                        }
                    ],
                    "classes": [],
                    "submodules": []
                },
                {
                    "type": "module",
                    "name": "phi.physics.sph",
                    "docstring": "Tools for running Smoothed Particle Hydrodynamics (SPH) simulations.\n\n1. Create particles as a `Geometry` collections.\n2. Use `neighbor_graph` to find neighbor particles and compute kernel weights.\n3. Use custom function or built-in physics operations to integrate the dynamics.",
                    "functions": [
                        {
                            "name": "evaluate_kernel",
                            "qualname": "evaluate_kernel",
                            "docstring": "Compute the SPH kernel value or a derivative of the kernel function.\n\nFor kernels that only depends on the squared distance, such as `poly6`, the `distance` variable is not used.\nInstead, the squared distance is derived from `delta`.\n\nArgs:\n    delta: Vectors to neighbors, i.e. position differences.\n    distance: Scalar distance to neighbors.\n    h: Support radius / smoothing length / maximum distance / cutoff.\n    spatial_rank: Dimensionality of the simulation.\n    kernel: Which kernel to use, one of `'quintic-spline'`, `'wendland-c2'`, `'poly6'`.\n    types: Ordered `tuple` of derivatives to compute, `'kernel'`, `'grad'`, `'laplace'`.\n\nReturns:\n    `phi.math.Tensor`",
                            "signature": "(delta, distance, h, spatial_rank: int, kernel: str, types: Sequence[str] = ('kernel',)) -> Dict[str, phiml.math._tensors.Tensor]"
                        },
                        {
                            "name": "expected_neighbors",
                            "qualname": "expected_neighbors",
                            "docstring": "Given the average element volume and support radius, returns the average number of neighbors for a region filled with particles.\n\nArgs:\n    volume: Average particle volume.\n    support_radius: Other elements are considered neighbors if their center lies within a sphere of this radius around a particle.\n    spatial_rank: Spatial rank of the simulation.\n\nReturns:\n    Number of expected neighbors.",
                            "signature": "(volume: phiml.math._tensors.Tensor, support_radius, spatial_rank: int)"
                        },
                        {
                            "name": "neighbor_graph",
                            "qualname": "neighbor_graph",
                            "docstring": "Build a `phi.geom.Graph` based on proximity of `nodes` and evaluates the kernel function.\n\nArgs:\n    nodes: Particles including obstacle particles as `Geometry` collection.\n    kernel: Kernel function to evaluate.\n    boundary: Marks ranges of nodes as boundary particles, see `phi.geom.Graph`.\n    desired_neighbors: Target average number of neighbors per particle. This determines the support radius (cutoff) used.\n    compute: Comma-separated `str` of kernel properties to compute on the graph edges. Can contain `'kernel'`, `'grad'`, `'laplace'`.\n        If no kernel property is given, the edge values will be set to the inverse distance between nodes instead.\n    format: Sparse format in which store neighborhood information. Allowed strings are `'dense', `'csr'`, `'coo'`, `'csc'`.\n    search_method: Neighborhood search method, see `phi.math.pairwise_differences`.\n    domain: (Optional) Specify a fixed domain size in which the centers of all nodes must be located.\n        This is required for periodic domains.\n    periodic: Which domain boundaries should be treated as periodic, i.e. particles on opposite sides are neighbors.\n        Can be specified as a `bool` for all sides or as a vector-valued boolean `Tensor` to specify periodicity by direction.\n\nReturns:\n    `phi.geom.Graph` with edge values storing the kernel values, i.e. the interaction strength between particles.",
                            "signature": "(nodes: phi.geom._geom.Geometry, kernel: str, boundary: Dict[str, Dict[str, slice]] = None, desired_neighbors: float = None, compute: str = 'kernel,grad', format='sparse', search_method='auto', domain: phi.geom._box.Box = None, periodic: Union[bool, phiml.math._tensors.Tensor] = False) -> phi.geom._graph.Graph"
                        }
                    ],
                    "classes": [],
                    "submodules": []
                }
            ]
        },
        {
            "type": "module",
            "name": "torch",
            "docstring": "PyTorch integration.\n\nImporting this module registers the PyTorch backend with `phiml.math`.\nWithout this, PyTorch tensors cannot be handled by `phiml.math` functions.\n\nTo make PyTorch the default backend, import `phi.torch.flow`.",
            "functions": [],
            "classes": [],
            "submodules": [
                {
                    "type": "module",
                    "name": "phi.torch.flow",
                    "docstring": "Standard import for PyTorch mode.\n\nExtends the import `from phi.flow import *` by PyTorch-related functions and modules.\n\nThe following PyTorch modules are included: `torch`, *torch.nn.functional* as `torchf`, `optim`.\n\nImporting this module registers the PyTorch backend as the default backend unless called within a backend context.\nNew tensors created via `phiml.math` functions will be backed by PyTorch tensors.\n\nSee `phi.flow`, `phi.tf.flow`, `phi.jax.flow`.",
                    "functions": [],
                    "classes": [],
                    "submodules": []
                },
                {
                    "type": "module",
                    "name": "phi.torch.nets",
                    "docstring": "PyTorch implementation of the unified machine learning API.\nEquivalent functions also exist for the other frameworks.\n\nFor API documentation, see https://tum-pbs.github.io/PhiFlow/Network_API .",
                    "functions": [],
                    "classes": [],
                    "submodules": []
                }
            ]
        },
        {
            "type": "module",
            "name": "vis",
            "docstring": "Visualization: plotting, interactive user interfaces.\n\nUse `view()` to show fields or field variables in an interactive user interface.\n\nUse `plot()` to plot fields using Matplotlib.\n\nSee the user interface documentation at https://tum-pbs.github.io/PhiFlow/Visualization.html",
            "functions": [
                {
                    "name": "action",
                    "qualname": "action",
                    "docstring": "",
                    "signature": "(fun)"
                },
                {
                    "name": "close",
                    "qualname": "close",
                    "docstring": "Close and destroy a figure.\n\nArgs:\n    figure: (Optional) A figure that was created using `plot()`.\n        If not specified, closes the figure created most recently.",
                    "signature": "(figure=None)"
                },
                {
                    "name": "control",
                    "qualname": "control",
                    "docstring": "Mark a variable as controllable by any GUI created via `view()`.\n\nExample:\n>>> dt = control(1.0, (0.1, 10), name=\"Time increment (dt)\")\n\nThis will cause a control component (slider, checkbox, text field, drop-down, etc.) to be generated in the user interface.\nChanges to that component will immediately be reflected in the Python variable assigned to the control.\nThe Python variable will always hold a primitive type, such as `int`, `float\u00b4, `bool` or `str`.\n\nArgs:\n    value: Initial value. Must be either `int`, `float`, `bool` or `str`.\n    range: (Optional) Specify range of possible values as `(min, max)`. Only for `int`, `float` and `str` values.\n    description: Human-readable description.\n    **kwargs: Additional arguments to determine the appearance of the GUI component,\n        e.g. `rows` for text fields or `log=False` for float sliders.\n\nReturns:\n    `value`",
                    "signature": "(value, range: tuple = None, description='', **kwargs)"
                },
                {
                    "name": "load_scalars",
                    "qualname": "load_scalars",
                    "docstring": "Read one or a `Tensor` of scalar logs as curves.\n\nArgs:\n    scene: `Scene` or `str`. Directory containing the log files.\n    name: Log file base name.\n    prefix: Log file prefix.\n    suffix: Log file suffix.\n    x: 'steps'  or 'time'\n    entries_dim: Curve dimension.\n\nReturns:\n    `Tensor` containing `entries_dim` and `vector`.",
                    "signature": "(scene: phi.field._scene.Scene, name: str, prefix='log_', suffix='.txt', x: Optional[str] = 'steps', entries_dim=(iteration\u02e2=None), batch_dim=(batch\u1d47=None))"
                },
                {
                    "name": "overlay",
                    "qualname": "overlay",
                    "docstring": "Specify that multiple fields should be drawn on top of one another in the same figure.\nThe fields will be plotted in the order they are given, i.e. the last field on top.\n\n>>> plot(vis.overlay(heatmap, points, velocity))\n\nArgs:\n    *fields: `Field` or `Tensor` instances\n\nReturns:\n    Plottable object",
                    "signature": "(*fields: Union[phi.field._field.Field, phiml.math._tensors.Tensor, phi.geom._geom.Geometry]) -> phiml.math._tensors.Tensor"
                },
                {
                    "name": "plot",
                    "qualname": "plot",
                    "docstring": "Creates one or multiple figures and sub-figures and plots the given fields.\n\nTo show the figures, use `show()`.\n\nThe arguments `row_dims`, `col_dims`, `animate` and `overlay` control how data is presented.\nEach accepts dimensions as a `str`, `Shape`, tuple, list or type function.\nIn addition to the dimensions present on the data to be plotted, the dimensions `args` is created if multiple arguments are passed,\nand `tuple`, `list`, `dict` are generated for corresponding objects to be plotted.\n\nArgs:\n    fields: Fields or Tensors to plot.\n    lib: Plotting library name or reference. Valid names are `'matplotlib'`, `'plotly'` and `'console'`.\n    row_dims: Batch dimensions along which sub-figures should be laid out vertically.\n        `Shape` or comma-separated names as `str`, `tuple` or `list`.\n    col_dims: Batch dimensions along which sub-figures should be laid out horizontally.\n        `Shape` or comma-separated names as `str`, `tuple` or `list`.\n    title: `str` for figures with a single subplot.\n        For subplots, pass a string `Tensor` matching the content dimensions, i.e. `row_dims` and `col_dims`.\n        Passing a `tuple`, `list` or `dict`, will create a tensor with these names internally.\n    size: Figure size in inches, `(width, height)`.\n    same_scale: Whether to use the same axis limits for all sub-figures.\n    log_dims: Dimensions for which the plot axes should be scaled logarithmically.\n        Can be given as a comma-separated `str`, a sequence of dimension names or a `Shape`.\n        Use `'_'` to scale unnamed axes logarithmically, e.g. the y-axis of scalar functions.\n    show_color_bar: Whether to display color bars for heat maps.\n    color: `Tensor` of line / marker colors.\n        The color can be specified either as a cycle index (int tensor) or as a hex code (str tensor).\n        The color of different lines and markers can vary.\n    alpha: Opacity as `float` or `Tensor`.\n        This affects all elements, not only line plots.\n        Opacity can vary between lines and markers.\n    err: Expected deviation from the value given in `fields`.\n        For supported plots, adds error bars of size *2\u00b7err*.\n        If the plotted data is the mean of some distribution, a good choice for `err` is the standard deviation along the mean dims.\n    animate: Time dimension to animate.\n        If not present in the data, will produce a regular plot instead.\n    overlay: Dimensions along which elements should be overlaid in the same subplot.\n        The default is only the `overlay` dimension which is created by `overlay()`.\n    frame_time: Interval between frames in the animation.\n    repeat: Whether the animation should loop.\n\nReturns:\n    `Tensor` of figure objects.\n    The tensor contains those dimensions of `fields` that were not reduced by `row_dims`, `col_dims` or `animate`.\n    Currently, only single-figure plots are supported.\n\n    In case of an animation, a displayable animation object will be returned instead of a `Tensor`.",
                    "signature": "(*fields: Union[phi.field._field.Field, phiml.math._tensors.Tensor, phi.geom._geom.Geometry, list, tuple, dict], lib: Union[str, phi.vis._vis_base.PlottingLibrary] = None, row_dims: Union[str, Sequence, set, phiml.math._shape.Shape, Callable, NoneType] = None, col_dims: Union[str, Sequence, set, phiml.math._shape.Shape, Callable, NoneType] = <function batch at 0x000001AACFADFD80>, animate: Union[str, Sequence, set, phiml.math._shape.Shape, Callable, NoneType] = None, overlay: Union[str, Sequence, set, phiml.math._shape.Shape, Callable, NoneType] = 'overlay', title: Union[str, phiml.math._tensors.Tensor, list, tuple] = None, size=None, same_scale: Union[bool, phiml.math._shape.Shape, tuple, list, str] = True, log_dims: Union[str, tuple, list, phiml.math._shape.Shape] = '', show_color_bar=True, color: Union[str, int, phiml.math._tensors.Tensor, list, tuple] = None, alpha: Union[float, phiml.math._tensors.Tensor, list, tuple] = 1.0, err: Union[phiml.math._tensors.Tensor, tuple, list, float] = 0.0, frame_time=100, repeat=True, plt_params: Dict = None, max_subfigures=20)"
                },
                {
                    "name": "plot_scalars",
                    "qualname": "plot_scalars",
                    "docstring": "",
                    "signature": "(*args, **kwargs)"
                },
                {
                    "name": "savefig",
                    "qualname": "write_image",
                    "docstring": "Save a figure to an image file.\n\nArgs:\n    figure: Matplotlib or Plotly figure or text.\n    path: File path.\n    dpi: Pixels per inch.\n    close: Whether to close the figure after saving it.\n    transparent: Whether to save the figure with transparent background.",
                    "signature": "(path: str, figure=None, dpi=120.0, close=False, transparent=True)"
                },
                {
                    "name": "show",
                    "qualname": "show",
                    "docstring": "Args:\n    See `plot()`.",
                    "signature": "(*fields: Union[phi.field._field.Field, phiml.math._tensors.Tensor, phi.geom._geom.Geometry, list, tuple, dict], lib: Union[str, phi.vis._vis_base.PlottingLibrary] = None, row_dims: Union[str, Sequence, set, phiml.math._shape.Shape, Callable, NoneType] = None, col_dims: Union[str, Sequence, set, phiml.math._shape.Shape, Callable, NoneType] = <function batch at 0x000001AACFADFD80>, animate: Union[str, Sequence, set, phiml.math._shape.Shape, Callable, NoneType] = None, overlay: Union[str, Sequence, set, phiml.math._shape.Shape, Callable, NoneType] = 'overlay', title: Union[str, phiml.math._tensors.Tensor, list, tuple] = None, size=None, same_scale: Union[bool, phiml.math._shape.Shape, tuple, list, str] = True, log_dims: Union[str, tuple, list, phiml.math._shape.Shape] = '', show_color_bar=True, color: Union[str, int, phiml.math._tensors.Tensor, list, tuple] = None, alpha: Union[float, phiml.math._tensors.Tensor, list, tuple] = 1.0, err: Union[phiml.math._tensors.Tensor, tuple, list, float] = 0.0, frame_time=100, repeat=True, plt_params: Dict = None, max_subfigures=20)"
                },
                {
                    "name": "show_hist",
                    "qualname": "show_hist",
                    "docstring": "",
                    "signature": "(data: phiml.math._tensors.Tensor, bins=(bins\u2071=20), weights=1, same_bins: Union[str, Sequence, set, phiml.math._shape.Shape, Callable, NoneType] = None)"
                },
                {
                    "name": "smooth",
                    "qualname": "smooth",
                    "docstring": "Applies a smoothing kernel to curves, all channels independently.\n\nArgs:\n    curves: `Tensor` containing at least one spatial dimension\n    n: Kernel size, i.e. number of values to average.\n\nReturns:\n    Smoothed curves as `Tensor`",
                    "signature": "(curves: phiml.math._tensors.Tensor, n: int, ext: phiml.math.extrapolation.Extrapolation = <phiml.math.extrapolation._SymmetricGradientExtrapolation object at 0x000001AACFBBD550>) -> phiml.math._tensors.Tensor"
                },
                {
                    "name": "write_image",
                    "qualname": "write_image",
                    "docstring": "Save a figure to an image file.\n\nArgs:\n    figure: Matplotlib or Plotly figure or text.\n    path: File path.\n    dpi: Pixels per inch.\n    close: Whether to close the figure after saving it.\n    transparent: Whether to save the figure with transparent background.",
                    "signature": "(path: str, figure=None, dpi=120.0, close=False, transparent=True)"
                }
            ],
            "classes": [],
            "submodules": []
        }
    ],
    "docstring": "Unified documentation for the phi package and its submodules."
}